//! Async Task Manager for TUI
//!
//! Provides non-blocking execution of Graph API calls and other async operations.
//! Uses channels to communicate between the async runtime and the TUI main loop.
//!
//! Architecture:
//! - TUI main loop runs on the main thread (synchronous)
//! - Async tasks run on a background tokio runtime
//! - Communication via crossbeam channels (thread-safe, non-blocking)
//!
//! Task ID Contract (v0.1.2):
//! - The TUI generates a unique task ID before sending any request
//! - The worker echoes that same ID in all Progress and Completed responses
//! - This ensures the TUI can match responses to the originating request

use crate::config::ConfigManager;
use crate::error::Result;
use crossbeam_channel::{Receiver, Sender, TrySendError, bounded};
use std::sync::Arc;
use std::thread;

/// Envelope wrapping a task request with its TUI-generated ID
///
/// This is the single source of truth for task identification.
/// The TUI creates the ID, the worker echoes it back.
#[derive(Debug, Clone)]
pub struct TaskEnvelope {
    /// Unique task ID generated by the TUI (format: `{type}_{timestamp}`)
    pub id: String,
    /// The actual task request
    pub request: TaskRequest,
}

impl TaskEnvelope {
    /// Create a new envelope with an auto-generated ID based on request type
    pub fn new(request: TaskRequest) -> Self {
        let prefix = match &request {
            TaskRequest::LoadPolicies { .. } => "load_policies",
            TaskRequest::DeployBaseline { .. } => "deploy_baseline",
            TaskRequest::DeployConditionalAccess { .. } => "deploy_ca",
            TaskRequest::ApplySettings { .. } => "apply_settings",
            TaskRequest::TestAuth { .. } => "test_auth",
            TaskRequest::FetchSignInLogs { .. } => "fetch_signin_logs",
            TaskRequest::FetchRiskyUsers { .. } => "fetch_risky_users",
            TaskRequest::FetchRiskySignIns { .. } => "fetch_risky_signins",
            TaskRequest::FetchDirectoryAudit { .. } => "fetch_directory_audit",
            TaskRequest::FetchSecuritySummary { .. } => "fetch_security_summary",
            TaskRequest::Shutdown => "shutdown",
        };
        let id = format!("{}_{}", prefix, chrono::Utc::now().timestamp_millis());
        Self { id, request }
    }

    /// Create an envelope with a specific ID (for testing or retries)
    pub fn with_id(id: String, request: TaskRequest) -> Self {
        Self { id, request }
    }
}

/// Messages sent from TUI to the task worker
#[derive(Debug, Clone)]
pub enum TaskRequest {
    /// Load policies from Graph API
    LoadPolicies {
        tenant_name: String,
        policy_type: PolicyType,
    },
    /// Deploy a baseline
    DeployBaseline {
        tenant_name: String,
        baseline_type: String,
        baseline_data: serde_json::Value,
    },
    /// Deploy CA policies
    DeployConditionalAccess { tenant_name: String },
    /// Apply settings to tenant
    ApplySettings {
        tenant_name: String,
        category: SettingsCategory,
        settings: std::collections::HashMap<String, bool>,
    },
    /// Test authentication
    TestAuth { tenant_name: String },
    // =========================================================================
    // Security Monitoring Tasks
    // =========================================================================
    /// Fetch sign-in logs
    FetchSignInLogs { tenant_name: String, limit: u32 },
    /// Fetch risky users
    FetchRiskyUsers { tenant_name: String },
    /// Fetch risky sign-ins
    FetchRiskySignIns { tenant_name: String, limit: u32 },
    /// Fetch directory audit logs
    FetchDirectoryAudit { tenant_name: String, limit: u32 },
    /// Fetch security summary
    FetchSecuritySummary { tenant_name: String },
    /// Shutdown the worker
    Shutdown,
}

/// Policy types for loading
#[derive(Debug, Clone)]
pub enum PolicyType {
    Compliance,
    Configuration,
    SettingsCatalog,
    ConditionalAccess,
    Apps,
    All,
}

/// Settings categories
#[derive(Debug, Clone)]
pub enum SettingsCategory {
    Defender,
    Exchange,
    SharePoint,
    Teams,
    All,
}

/// Progress update from worker to TUI
#[derive(Debug, Clone)]
pub struct TaskProgress {
    pub task_id: String,
    pub percent: u16,
    pub message: String,
    pub phase: String,
}

/// Result of a completed task
#[derive(Debug, Clone)]
pub enum TaskResult {
    /// Policies loaded successfully
    PoliciesLoaded { policies: Vec<PolicyData> },
    /// Baseline deployed
    BaselineDeployed { count: usize, message: String },
    /// CA policies deployed
    CaDeployed { count: usize, message: String },
    /// Settings applied
    SettingsApplied { message: String },
    /// Auth test result
    AuthResult { success: bool, message: String },
    // =========================================================================
    // Security Monitoring Results
    // =========================================================================
    /// Sign-in logs loaded
    SignInLogsLoaded { logs: Vec<SignInLogData> },
    /// Risky users loaded
    RiskyUsersLoaded { users: Vec<RiskyUserData> },
    /// Risky sign-ins loaded
    RiskySignInsLoaded { sign_ins: Vec<RiskySignInData> },
    /// Directory audit logs loaded
    DirectoryAuditLoaded { audits: Vec<DirectoryAuditData> },
    /// Security summary loaded
    SecuritySummaryLoaded { summary: SecuritySummaryData },
    /// Task failed
    Error { message: String },
}

// ============================================================================
// Security Monitoring Data Types
// ============================================================================

/// Sign-in log entry for TUI display
#[derive(Debug, Clone)]
pub struct SignInLogData {
    pub user: String,
    pub app: String,
    pub status: String,
    pub location: String,
    pub ip_address: String,
    pub device: String,
    pub timestamp: String,
    pub risk_level: String,
}

/// Risky user entry for TUI display
#[derive(Debug, Clone)]
pub struct RiskyUserData {
    pub display_name: String,
    pub user_principal_name: String,
    pub risk_level: String,
    pub risk_state: String,
    pub risk_detail: String,
    pub last_updated: String,
}

/// Risky sign-in entry for TUI display
#[derive(Debug, Clone)]
pub struct RiskySignInData {
    pub user: String,
    pub app: String,
    pub risk_level: String,
    pub risk_state: String,
    pub risk_detail: String,
    pub location: String,
    pub ip_address: String,
    pub timestamp: String,
}

/// Directory audit entry for TUI display
#[derive(Debug, Clone)]
pub struct DirectoryAuditData {
    pub activity: String,
    pub category: String,
    pub initiated_by: String,
    pub target: String,
    pub result: String,
    pub timestamp: String,
}

/// Security summary for dashboard
#[derive(Debug, Clone)]
pub struct SecuritySummaryData {
    pub total_risky_users: usize,
    pub high_risk_users: usize,
    pub medium_risk_users: usize,
    pub low_risk_users: usize,
    pub recent_risky_sign_ins: usize,
    pub failed_sign_ins_24h: usize,
    pub recent_admin_actions: usize,
}

/// Policy data returned from Graph
#[derive(Debug, Clone)]
pub struct PolicyData {
    pub name: String,
    pub policy_type: String,
    pub status: String,
    pub platform: String,
    pub assignments: usize,
    pub last_modified: String,
}

/// Messages sent from worker to TUI
#[derive(Debug, Clone)]
pub enum TaskResponse {
    /// Progress update
    Progress(TaskProgress),
    /// Task completed
    Completed { task_id: String, result: TaskResult },
    /// Worker is ready
    Ready,
}

/// Error type for task submission failures
#[derive(Debug)]
pub enum TaskSendError {
    /// Channel is full (back-pressure)
    ChannelFull(TaskEnvelope),
    /// Channel is disconnected (worker died)
    Disconnected(TaskEnvelope),
}

impl std::fmt::Display for TaskSendError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ChannelFull(_) => write!(f, "Task queue is full - please wait"),
            Self::Disconnected(_) => write!(f, "Worker unavailable - restart TUI"),
        }
    }
}

impl std::error::Error for TaskSendError {}

/// Handle for sending tasks to the worker
pub struct TaskSender {
    tx: Sender<TaskEnvelope>,
}

impl TaskSender {
    /// Send a task envelope to the worker (blocking)
    pub fn send(&self, envelope: TaskEnvelope) -> std::result::Result<(), TaskSendError> {
        self.tx
            .send(envelope.clone())
            .map_err(|_| TaskSendError::Disconnected(envelope))
    }

    /// Try to send without blocking - returns error if channel full or disconnected
    pub fn try_send(&self, envelope: TaskEnvelope) -> std::result::Result<(), TaskSendError> {
        match self.tx.try_send(envelope) {
            Ok(()) => Ok(()),
            Err(TrySendError::Full(env)) => Err(TaskSendError::ChannelFull(env)),
            Err(TrySendError::Disconnected(env)) => Err(TaskSendError::Disconnected(env)),
        }
    }

    /// Check if the worker is still connected
    /// Note: This is a best-effort check - channel could disconnect after this returns
    pub fn is_connected(&self) -> bool {
        // The only reliable way to know is to try sending
        // This returns true if channel exists (even if empty)
        self.tx.capacity().is_some()
    }

    /// Request graceful shutdown
    pub fn shutdown(&self) {
        let envelope = TaskEnvelope::new(TaskRequest::Shutdown);
        let _ = self.tx.send(envelope);
    }

    /// Create a test stub that can be used in unit tests
    /// The channel is connected but no worker is listening
    #[cfg(test)]
    pub fn test_stub() -> Self {
        let (tx, _rx) = bounded::<TaskEnvelope>(1);
        Self { tx }
    }
}

/// Handle for receiving responses from the worker
pub struct TaskReceiver {
    rx: Receiver<TaskResponse>,
}

impl TaskReceiver {
    /// Try to receive a response without blocking
    pub fn try_recv(&self) -> Option<TaskResponse> {
        self.rx.try_recv().ok()
    }

    /// Drain all available responses
    pub fn drain(&self) -> Vec<TaskResponse> {
        let mut responses = Vec::new();
        while let Some(resp) = self.try_recv() {
            responses.push(resp);
        }
        responses
    }
}

/// Spawn the background task worker
/// Returns handles for sending requests and receiving responses
pub fn spawn_task_worker(config: ConfigManager) -> (TaskSender, TaskReceiver) {
    let (request_tx, request_rx) = bounded::<TaskEnvelope>(32);
    let (response_tx, response_rx) = bounded::<TaskResponse>(64);

    let config = Arc::new(config);

    thread::spawn(move || {
        // Create a new tokio runtime for this thread
        let rt = match tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
        {
            Ok(rt) => rt,
            Err(e) => {
                tracing::error!("Failed to create async runtime: {}", e);
                return;
            }
        };

        rt.block_on(async move {
            // Signal that worker is ready
            let _ = response_tx.send(TaskResponse::Ready);
            tracing::info!("Task worker ready");

            while let Ok(envelope) = request_rx.recv() {
                // Extract the TUI-provided task ID - this is the single source of truth
                let task_id = envelope.id;
                tracing::debug!("Processing task: {}", task_id);

                match envelope.request {
                    TaskRequest::Shutdown => {
                        tracing::info!("Task worker shutting down");
                        break;
                    }
                    TaskRequest::LoadPolicies {
                        tenant_name,
                        policy_type,
                    } => {
                        // Echo back the TUI-provided ID in all responses
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Connecting to Graph API...".into(),
                            phase: "init".into(),
                        }));

                        let result = load_policies_async(
                            &config,
                            &tenant_name,
                            &policy_type,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::DeployBaseline {
                        tenant_name,
                        baseline_type,
                        baseline_data,
                    } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: format!("Preparing {} baseline...", baseline_type),
                            phase: "init".into(),
                        }));

                        let result = deploy_baseline_async(
                            &config,
                            &tenant_name,
                            &baseline_type,
                            &baseline_data,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::DeployConditionalAccess { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Generating CA policies...".into(),
                            phase: "init".into(),
                        }));

                        let result =
                            deploy_ca_async(&config, &tenant_name, &response_tx, &task_id).await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::ApplySettings {
                        tenant_name,
                        category,
                        settings,
                    } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Applying settings...".into(),
                            phase: "init".into(),
                        }));

                        let result = apply_settings_async(
                            &config,
                            &tenant_name,
                            &category,
                            &settings,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::TestAuth { tenant_name } => {
                        let result = test_auth_async(&config, &tenant_name).await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    // =========================================================
                    // Security Monitoring Tasks
                    // =========================================================
                    TaskRequest::FetchSignInLogs { tenant_name, limit } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching sign-in logs...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_signin_logs_async(
                            &config,
                            &tenant_name,
                            limit,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::FetchRiskyUsers { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching risky users...".into(),
                            phase: "init".into(),
                        }));
                        let result =
                            fetch_risky_users_async(&config, &tenant_name, &response_tx, &task_id)
                                .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::FetchRiskySignIns { tenant_name, limit } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching risky sign-ins...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_risky_signins_async(
                            &config,
                            &tenant_name,
                            limit,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::FetchDirectoryAudit { tenant_name, limit } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching directory audit logs...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_directory_audit_async(
                            &config,
                            &tenant_name,
                            limit,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                    TaskRequest::FetchSecuritySummary { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching security summary...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_security_summary_async(
                            &config,
                            &tenant_name,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed { task_id, result });
                    }
                }
            }
        });
    });

    (
        TaskSender { tx: request_tx },
        TaskReceiver { rx: response_rx },
    )
}

// ============================================================================
// Async Task Implementations
// ============================================================================

async fn load_policies_async(
    config: &ConfigManager,
    tenant_name: &str,
    policy_type: &PolicyType,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    // Get Graph client
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 30,
        message: "Fetching policies...".into(),
        phase: "fetch".into(),
    }));

    // Fetch policies based on type
    let policies = match policy_type {
        PolicyType::ConditionalAccess => fetch_ca_policies(&client).await,
        PolicyType::Compliance => fetch_compliance_policies(&client).await,
        PolicyType::Configuration | PolicyType::SettingsCatalog => {
            fetch_config_policies(&client).await
        }
        PolicyType::Apps => fetch_app_policies(&client).await,
        PolicyType::All => fetch_all_policies(&client).await,
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    match policies {
        Ok(p) => TaskResult::PoliciesLoaded { policies: p },
        Err(e) => TaskResult::Error {
            message: e.to_string(),
        },
    }
}

async fn fetch_ca_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct CaResponse {
        value: Vec<CaPolicy>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct CaPolicy {
        #[allow(dead_code)]
        id: String,
        display_name: String,
        state: String,
        #[serde(default)]
        modified_date_time: Option<String>,
    }

    let response: CaResponse = client.get("identity/conditionalAccess/policies").await
        .map_err(|e| {
            // Enhance error message for permission issues
            let err_str = e.to_string();
            if err_str.contains("403") || err_str.contains("Authorization") {
                crate::error::Ctl365Error::GraphApiError(
                    "Access denied. Ensure the app has 'Policy.Read.All' or 'Policy.ReadWrite.ConditionalAccess' permission.".into()
                )
            } else if err_str.contains("404") {
                crate::error::Ctl365Error::GraphApiError(
                    "Conditional Access API not available. Requires Entra ID P1/P2 license.".into()
                )
            } else {
                e
            }
        })?;

    Ok(response
        .value
        .into_iter()
        .map(|p| PolicyData {
            name: p.display_name,
            policy_type: "Conditional Access".into(),
            status: match p.state.as_str() {
                "enabled" => "Deployed",
                "enabledForReportingButNotEnforced" => "Report-Only",
                "disabled" => "Disabled",
                _ => "Unknown",
            }
            .into(),
            platform: "All".into(),
            assignments: 0, // Would need additional API call
            last_modified: p.modified_date_time.unwrap_or_else(|| "-".into()),
        })
        .collect())
}

async fn fetch_compliance_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct ComplianceResponse {
        value: Vec<CompliancePolicy>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct CompliancePolicy {
        #[allow(dead_code)]
        id: String,
        display_name: String,
        #[serde(default)]
        last_modified_date_time: Option<String>,
    }

    let response: ComplianceResponse = client
        .get_beta("deviceManagement/deviceCompliancePolicies")
        .await?;

    Ok(response
        .value
        .into_iter()
        .map(|p| PolicyData {
            name: p.display_name,
            policy_type: "Compliance".into(),
            status: "Deployed".into(),
            platform: "Windows".into(), // Would need to parse from policy
            assignments: 0,
            last_modified: p.last_modified_date_time.unwrap_or_else(|| "-".into()),
        })
        .collect())
}

async fn fetch_config_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct ConfigResponse {
        value: Vec<ConfigPolicy>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct ConfigPolicy {
        #[allow(dead_code)]
        id: String,
        name: String,
        #[serde(default)]
        last_modified_date_time: Option<String>,
    }

    let response: ConfigResponse = client
        .get_beta("deviceManagement/configurationPolicies")
        .await?;

    Ok(response
        .value
        .into_iter()
        .map(|p| PolicyData {
            name: p.name,
            policy_type: "Settings Catalog".into(),
            status: "Deployed".into(),
            platform: "Windows".into(),
            assignments: 0,
            last_modified: p.last_modified_date_time.unwrap_or_else(|| "-".into()),
        })
        .collect())
}

async fn fetch_app_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct AppResponse {
        value: Vec<App>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct App {
        #[allow(dead_code)]
        id: String,
        display_name: String,
        #[serde(default, rename = "@odata.type")]
        odata_type: Option<String>,
        #[serde(default)]
        last_modified_date_time: Option<String>,
    }

    let response: AppResponse = client
        .get_beta("deviceAppManagement/mobileApps?$top=50")
        .await?;

    Ok(response
        .value
        .into_iter()
        .map(|a| {
            let app_type = a
                .odata_type
                .as_deref()
                .map(|t| t.replace("#microsoft.graph.", "").replace("App", ""))
                .unwrap_or_else(|| "Unknown".into());
            PolicyData {
                name: a.display_name,
                policy_type: app_type,
                status: "Deployed".into(),
                platform: "Windows".into(),
                assignments: 0,
                last_modified: a.last_modified_date_time.unwrap_or_else(|| "-".into()),
            }
        })
        .collect())
}

async fn fetch_all_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    let mut all = Vec::new();

    // Fetch each type, ignoring errors for individual types
    if let Ok(ca) = fetch_ca_policies(client).await {
        all.extend(ca);
    }
    if let Ok(compliance) = fetch_compliance_policies(client).await {
        all.extend(compliance);
    }
    if let Ok(config) = fetch_config_policies(client).await {
        all.extend(config);
    }

    Ok(all)
}

async fn deploy_baseline_async(
    config: &ConfigManager,
    tenant_name: &str,
    baseline_type: &str,
    baseline_data: &serde_json::Value,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let policies = baseline_data
        .get("policies")
        .and_then(|p| p.as_array())
        .map(|a| a.to_vec())
        .unwrap_or_default();

    let total = policies.len();
    let mut deployed = 0;
    let mut errors = Vec::new();

    for (i, policy) in policies.iter().enumerate() {
        let percent = ((i + 1) * 100 / total.max(1)) as u16;
        let policy_name = policy
            .get("displayName")
            .or_else(|| policy.get("name"))
            .and_then(|n| n.as_str())
            .unwrap_or("Unknown");

        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
            task_id: task_id.to_string(),
            percent,
            message: format!("Deploying: {}", policy_name),
            phase: "deploy".into(),
        }));

        // Determine endpoint based on policy type
        let odata_type = policy
            .get("@odata.type")
            .and_then(|t| t.as_str())
            .unwrap_or("");

        let endpoint = if odata_type.contains("deviceCompliancePolicy") {
            "deviceManagement/deviceCompliancePolicies"
        } else if odata_type.contains("configurationPolicy") {
            "deviceManagement/configurationPolicies"
        } else {
            continue; // Skip unknown types
        };

        match client
            .post_beta::<_, serde_json::Value>(endpoint, policy)
            .await
        {
            Ok(_) => deployed += 1,
            Err(e) => errors.push(format!("{}: {}", policy_name, e)),
        }
    }

    // Record audit
    crate::tui::change_tracker::record_baseline_deployed(baseline_type, deployed, tenant_name);

    if errors.is_empty() {
        TaskResult::BaselineDeployed {
            count: deployed,
            message: format!("Successfully deployed {} policies", deployed),
        }
    } else {
        TaskResult::BaselineDeployed {
            count: deployed,
            message: format!(
                "Deployed {} policies with {} errors: {}",
                deployed,
                errors.len(),
                errors.join("; ")
            ),
        }
    }
}

async fn deploy_ca_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::templates::ca_baseline_2025;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 5,
        message: "Generating 44 CA policies...".into(),
        phase: "generate".into(),
    }));

    // Generate CA policies
    let baseline = ca_baseline_2025::CABaseline2025::generate();
    let policies: Vec<serde_json::Value> = baseline
        .policies
        .iter()
        .map(ca_baseline_2025::CABaseline2025::to_graph_json)
        .collect();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let total = policies.len();
    let mut deployed = 0;
    let mut errors = Vec::new();

    for (i, policy) in policies.iter().enumerate() {
        let percent = 10 + ((i + 1) * 90 / total.max(1)) as u16;
        let policy_name = policy
            .get("displayName")
            .and_then(|n| n.as_str())
            .unwrap_or("Unknown");

        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
            task_id: task_id.to_string(),
            percent,
            message: format!("Deploying: {}", policy_name),
            phase: "deploy".into(),
        }));

        match client
            .post::<_, serde_json::Value>("identity/conditionalAccess/policies", policy)
            .await
        {
            Ok(_) => deployed += 1,
            Err(e) => errors.push(format!("{}: {}", policy_name, e)),
        }

        // Small delay to avoid rate limiting
        tokio::time::sleep(std::time::Duration::from_millis(100)).await;
    }

    // Record audit
    crate::tui::change_tracker::record_baseline_deployed("CA Baseline 2025", deployed, tenant_name);

    if errors.is_empty() {
        TaskResult::CaDeployed {
            count: deployed,
            message: format!(
                "Successfully deployed {} CA policies in Report-Only mode",
                deployed
            ),
        }
    } else {
        TaskResult::CaDeployed {
            count: deployed,
            message: format!(
                "Deployed {} policies with {} errors",
                deployed,
                errors.len()
            ),
        }
    }
}

async fn apply_settings_async(
    config: &ConfigManager,
    tenant_name: &str,
    category: &SettingsCategory,
    settings: &std::collections::HashMap<String, bool>,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 20,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    // Build TenantConfiguration from settings
    use crate::tui::settings::TenantConfiguration;
    let mut tenant_config = TenantConfiguration::recommended();

    for (key, &value) in settings {
        match key.as_str() {
            "safe_links" => tenant_config.safe_links_enabled = value,
            "safe_links_teams" => tenant_config.safe_links_teams = value,
            "safe_links_office" => tenant_config.safe_links_office = value,
            "safe_attachments" => tenant_config.safe_attachments_enabled = value,
            "archive" => tenant_config.archive_mailbox = value,
            "forwarding" => tenant_config.external_forwarding_blocked = value,
            "zap" => tenant_config.zap_enabled = value,
            "external_access" => tenant_config.external_access = value,
            "guest_access" => tenant_config.teams_consumer_access = value,
            "meeting_recording" => tenant_config.meeting_recording = value,
            "anonymous_join" => tenant_config.anonymous_meeting_join = value,
            _ => {}
        }
    }

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Applying settings...".into(),
        phase: "apply".into(),
    }));

    let category_name = match category {
        SettingsCategory::Defender => "Defender",
        SettingsCategory::Exchange => "Exchange",
        SettingsCategory::SharePoint => "SharePoint",
        SettingsCategory::Teams => "Teams",
        SettingsCategory::All => "All",
    };

    // Apply based on category
    let result = match category {
        SettingsCategory::Defender => {
            crate::tui::menu::apply_defender_settings_from_config(
                config,
                tenant_name,
                &tenant_config,
            )
            .await
        }
        SettingsCategory::Exchange => {
            crate::tui::menu::apply_exchange_settings_from_config(
                config,
                tenant_name,
                &tenant_config,
            )
            .await
        }
        SettingsCategory::SharePoint => {
            crate::tui::menu::apply_sharepoint_settings_from_config(
                config,
                tenant_name,
                &tenant_config,
            )
            .await
        }
        SettingsCategory::Teams => {
            crate::tui::menu::apply_teams_settings_from_config(config, tenant_name, &tenant_config)
                .await
        }
        SettingsCategory::All => {
            crate::tui::menu::apply_all_settings_from_config(config, tenant_name, &tenant_config)
                .await
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    match result {
        Ok(msg) => {
            crate::tui::change_tracker::record_setting_change(
                category_name,
                "Settings Applied",
                None,
                "Configured via TUI",
                tenant_name,
            );
            TaskResult::SettingsApplied { message: msg }
        }
        Err(e) => {
            crate::tui::change_tracker::record_error(
                "Settings",
                category_name,
                &e.to_string(),
                tenant_name,
            );
            TaskResult::Error {
                message: e.to_string(),
            }
        }
    }
}

async fn test_auth_async(config: &ConfigManager, tenant_name: &str) -> TaskResult {
    use crate::graph::GraphClient;

    match GraphClient::from_config(config, tenant_name).await {
        Ok(client) => {
            // Try a simple API call to verify token works
            #[derive(serde::Deserialize)]
            struct OrgInfo {
                #[serde(default)]
                value: Vec<serde_json::Value>,
            }

            match client.get::<OrgInfo>("organization").await {
                Ok(_) => {
                    crate::tui::change_tracker::record_auth(tenant_name, true, None);
                    TaskResult::AuthResult {
                        success: true,
                        message: format!("Successfully authenticated to {}", tenant_name),
                    }
                }
                Err(e) => {
                    crate::tui::change_tracker::record_auth(
                        tenant_name,
                        false,
                        Some(&e.to_string()),
                    );
                    TaskResult::AuthResult {
                        success: false,
                        message: format!("API call failed: {}", e),
                    }
                }
            }
        }
        Err(e) => {
            crate::tui::change_tracker::record_auth(tenant_name, false, Some(&e.to_string()));
            TaskResult::AuthResult {
                success: false,
                message: format!("Authentication failed: {}", e),
            }
        }
    }
}

// ============================================================================
// Security Monitoring Async Functions
// ============================================================================

async fn fetch_signin_logs_async(
    config: &ConfigManager,
    tenant_name: &str,
    limit: u32,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching sign-in logs...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_recent_sign_ins(&client, limit).await {
        Ok(logs) => {
            let data: Vec<SignInLogData> = logs
                .into_iter()
                .map(|log| SignInLogData {
                    user: log
                        .user_display_name
                        .unwrap_or_else(|| log.user_principal_name.clone().unwrap_or_default()),
                    app: log.app_display_name.unwrap_or_default(),
                    status: log
                        .status
                        .map(|s| {
                            if s.error_code == Some(0) {
                                "Success".to_string()
                            } else {
                                s.failure_reason.unwrap_or_else(|| "Failed".to_string())
                            }
                        })
                        .unwrap_or_else(|| "Unknown".to_string()),
                    location: log
                        .location
                        .map(|l| {
                            format!(
                                "{}, {}",
                                l.city.unwrap_or_default(),
                                l.country_or_region.unwrap_or_default()
                            )
                        })
                        .unwrap_or_default(),
                    ip_address: log.ip_address.unwrap_or_default(),
                    device: log
                        .device_detail
                        .map(|d| d.display_name.or(d.operating_system).unwrap_or_default())
                        .unwrap_or_default(),
                    timestamp: log.created_date_time.to_rfc3339(),
                    risk_level: log
                        .risk_level_during_sign_in
                        .unwrap_or_else(|| "None".to_string()),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} sign-in logs", count),
                phase: "done".into(),
            }));

            TaskResult::SignInLogsLoaded { logs: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'AuditLog.Read.All' permission.".to_string()
            } else {
                format!("Failed to fetch sign-in logs: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_risky_users_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching risky users...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_risky_users(&client, None).await {
        Ok(users) => {
            let data: Vec<RiskyUserData> = users
                .into_iter()
                .map(|user| RiskyUserData {
                    display_name: user.user_display_name.unwrap_or_default(),
                    user_principal_name: user.user_principal_name.unwrap_or_default(),
                    risk_level: user
                        .risk_level
                        .map(|r| r.as_str().to_string())
                        .unwrap_or_else(|| "None".to_string()),
                    risk_state: user
                        .risk_state
                        .map(|r| format!("{:?}", r))
                        .unwrap_or_else(|| "Unknown".to_string()),
                    risk_detail: user.risk_detail.unwrap_or_default(),
                    last_updated: user
                        .risk_last_updated_date_time
                        .map(|dt| dt.to_rfc3339())
                        .unwrap_or_default(),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} risky users", count),
                phase: "done".into(),
            }));

            TaskResult::RiskyUsersLoaded { users: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'IdentityRiskyUser.Read.All' permission (requires Entra ID P1/P2).".to_string()
            } else if err_str.contains("404") {
                "Identity Protection not available. Requires Entra ID P1/P2 license.".to_string()
            } else {
                format!("Failed to fetch risky users: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_risky_signins_async(
    config: &ConfigManager,
    tenant_name: &str,
    limit: u32,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching risky sign-ins...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_risky_sign_ins(&client, Some(limit)).await {
        Ok(sign_ins) => {
            let data: Vec<RiskySignInData> = sign_ins
                .into_iter()
                .map(|si| RiskySignInData {
                    user: si
                        .user_display_name
                        .unwrap_or_else(|| si.user_principal_name.clone().unwrap_or_default()),
                    app: "N/A".to_string(), // RiskySignIn doesn't have app_display_name
                    risk_level: si
                        .risk_level
                        .map(|r| r.as_str().to_string())
                        .unwrap_or_else(|| "None".to_string()),
                    risk_state: si
                        .risk_state
                        .map(|r| format!("{:?}", r))
                        .unwrap_or_else(|| "Unknown".to_string()),
                    risk_detail: si.risk_detail.unwrap_or_default(),
                    location: si
                        .location
                        .map(|l| {
                            format!(
                                "{}, {}",
                                l.city.unwrap_or_default(),
                                l.country_or_region.unwrap_or_default()
                            )
                        })
                        .unwrap_or_default(),
                    ip_address: si.ip_address.unwrap_or_default(),
                    timestamp: si
                        .created_date_time
                        .map(|dt| dt.to_rfc3339())
                        .unwrap_or_default(),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} risky sign-ins", count),
                phase: "done".into(),
            }));

            TaskResult::RiskySignInsLoaded { sign_ins: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'IdentityRiskEvent.Read.All' permission (requires Entra ID P2).".to_string()
            } else if err_str.contains("404") {
                "Risky sign-ins not available. Requires Entra ID P2 license.".to_string()
            } else {
                format!("Failed to fetch risky sign-ins: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_directory_audit_async(
    config: &ConfigManager,
    tenant_name: &str,
    limit: u32,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching directory audit logs...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_recent_directory_audits(&client, limit).await {
        Ok(audits) => {
            let data: Vec<DirectoryAuditData> = audits
                .into_iter()
                .map(|audit| DirectoryAuditData {
                    activity: audit.activity_display_name,
                    category: audit.category,
                    initiated_by: audit
                        .initiated_by
                        .map(|i| {
                            i.user.and_then(|u| u.display_name).unwrap_or_else(|| {
                                i.app.and_then(|a| a.display_name).unwrap_or_default()
                            })
                        })
                        .unwrap_or_default(),
                    target: audit
                        .target_resources
                        .first()
                        .and_then(|t| t.display_name.clone())
                        .unwrap_or_default(),
                    result: audit
                        .result
                        .map(|r| format!("{:?}", r))
                        .unwrap_or_else(|| "Unknown".to_string()),
                    timestamp: audit.activity_date_time.to_rfc3339(),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} audit entries", count),
                phase: "done".into(),
            }));

            TaskResult::DirectoryAuditLoaded { audits: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'AuditLog.Read.All' permission.".to_string()
            } else {
                format!("Failed to fetch directory audit logs: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_security_summary_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 30,
        message: "Fetching security data...".into(),
        phase: "fetch".into(),
    }));

    // Fetch various security metrics - allow partial failures
    let risky_users = identity_protection::get_risky_users(&client, None)
        .await
        .unwrap_or_default();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Processing risky users...".into(),
        phase: "process".into(),
    }));

    let high_risk = risky_users
        .iter()
        .filter(|u| {
            matches!(
                u.risk_level,
                Some(crate::graph::identity_protection::RiskLevel::High)
            )
        })
        .count();
    let medium_risk = risky_users
        .iter()
        .filter(|u| {
            matches!(
                u.risk_level,
                Some(crate::graph::identity_protection::RiskLevel::Medium)
            )
        })
        .count();
    let low_risk = risky_users
        .iter()
        .filter(|u| {
            matches!(
                u.risk_level,
                Some(crate::graph::identity_protection::RiskLevel::Low)
            )
        })
        .count();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 70,
        message: "Fetching sign-in data...".into(),
        phase: "fetch".into(),
    }));

    let risky_sign_ins = identity_protection::get_risky_sign_ins(&client, Some(100))
        .await
        .unwrap_or_default();
    let failed_sign_ins = identity_protection::get_failed_sign_ins(&client, 100)
        .await
        .unwrap_or_default();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 90,
        message: "Fetching audit data...".into(),
        phase: "fetch".into(),
    }));

    let recent_audits = identity_protection::get_recent_directory_audits(&client, 50)
        .await
        .unwrap_or_default();

    let summary = SecuritySummaryData {
        total_risky_users: risky_users.len(),
        high_risk_users: high_risk,
        medium_risk_users: medium_risk,
        low_risk_users: low_risk,
        recent_risky_sign_ins: risky_sign_ins.len(),
        failed_sign_ins_24h: failed_sign_ins.len(),
        recent_admin_actions: recent_audits.len(),
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Security summary loaded".into(),
        phase: "done".into(),
    }));

    TaskResult::SecuritySummaryLoaded { summary }
}
