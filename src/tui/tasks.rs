//! Async Task Manager for TUI
//!
//! Provides non-blocking execution of Graph API calls and other async operations.
//! Uses channels to communicate between the async runtime and the TUI main loop.
//!
//! Architecture:
//! - TUI main loop runs on the main thread (synchronous)
//! - Async tasks run on a background tokio runtime
//! - Communication via crossbeam channels (thread-safe, non-blocking)
//!
//! Task ID Contract (v0.1.2):
//! - The TUI generates a unique task ID before sending any request
//! - The worker echoes that same ID in all Progress and Completed responses
//! - This ensures the TUI can match responses to the originating request

use crate::config::ConfigManager;
use crate::error::Result;
use crossbeam_channel::{Receiver, Sender, TrySendError, bounded};
use std::sync::Arc;
use std::thread;

/// Envelope wrapping a task request with its TUI-generated ID
///
/// This is the single source of truth for task identification.
/// The TUI creates the ID, the worker echoes it back.
#[derive(Debug, Clone)]
pub struct TaskEnvelope {
    /// Unique task ID generated by the TUI (format: `{type}_{timestamp}`)
    pub id: String,
    /// The actual task request
    pub request: TaskRequest,
}

impl TaskEnvelope {
    /// Create a new envelope with an auto-generated ID based on request type
    pub fn new(request: TaskRequest) -> Self {
        let prefix = match &request {
            TaskRequest::LoadPolicies { .. } => "load_policies",
            TaskRequest::DeployBaseline { .. } => "deploy_baseline",
            TaskRequest::DeployConditionalAccess { .. } => "deploy_ca",
            TaskRequest::ApplySettings { .. } => "apply_settings",
            TaskRequest::TestAuth { .. } => "test_auth",
            TaskRequest::TestConnection { .. } => "test_connection",
            TaskRequest::FetchSignInLogs { .. } => "fetch_signin_logs",
            TaskRequest::FetchRiskyUsers { .. } => "fetch_risky_users",
            TaskRequest::FetchRiskySignIns { .. } => "fetch_risky_signins",
            TaskRequest::FetchDirectoryAudit { .. } => "fetch_directory_audit",
            TaskRequest::FetchSecuritySummary { .. } => "fetch_security_summary",
            TaskRequest::GenerateTenantReport { .. } => "generate_tenant_report",
            TaskRequest::LoadAutopilotDevices { .. } => "load_autopilot_devices",
            TaskRequest::LoadAutopilotProfiles { .. } => "load_autopilot_profiles",
            TaskRequest::SyncAutopilot { .. } => "sync_autopilot",
            TaskRequest::LoadNamedLocations { .. } => "load_named_locations",
            TaskRequest::Shutdown => "shutdown",
        };
        let id = format!("{}_{}", prefix, chrono::Utc::now().timestamp_millis());
        Self { id, request }
    }

    /// Create an envelope with a specific ID (for testing or retries)
    pub fn with_id(id: String, request: TaskRequest) -> Self {
        Self { id, request }
    }
}

/// Messages sent from TUI to the task worker
#[derive(Debug, Clone)]
pub enum TaskRequest {
    /// Load policies from Graph API
    LoadPolicies {
        tenant_name: String,
        policy_type: PolicyType,
    },
    /// Deploy a baseline
    DeployBaseline {
        tenant_name: String,
        baseline_type: String,
        baseline_data: serde_json::Value,
    },
    /// Deploy CA policies
    DeployConditionalAccess { tenant_name: String },
    /// Apply settings to tenant
    ApplySettings {
        tenant_name: String,
        category: SettingsCategory,
        settings: std::collections::HashMap<String, bool>,
    },
    /// Test authentication
    TestAuth { tenant_name: String },
    /// Test connection and verify API permissions
    TestConnection { tenant_name: String },
    // =========================================================================
    // Security Monitoring Tasks
    // =========================================================================
    /// Fetch sign-in logs
    FetchSignInLogs { tenant_name: String, limit: u32 },
    /// Fetch risky users
    FetchRiskyUsers { tenant_name: String },
    /// Fetch risky sign-ins
    FetchRiskySignIns { tenant_name: String, limit: u32 },
    /// Fetch directory audit logs
    FetchDirectoryAudit { tenant_name: String, limit: u32 },
    /// Fetch security summary
    FetchSecuritySummary { tenant_name: String },
    /// Generate comprehensive tenant security report
    GenerateTenantReport { tenant_name: String },
    /// Load Autopilot devices
    LoadAutopilotDevices { tenant_name: String },
    /// Load Autopilot profiles
    LoadAutopilotProfiles { tenant_name: String },
    /// Sync Autopilot devices
    SyncAutopilot { tenant_name: String },
    /// Load Named Locations for CA
    LoadNamedLocations { tenant_name: String },
    /// Shutdown the worker
    Shutdown,
}

/// Policy types for loading
#[derive(Debug, Clone)]
pub enum PolicyType {
    Compliance,
    Configuration,
    SettingsCatalog,
    ConditionalAccess,
    Apps,
    All,
}

/// Settings categories
#[derive(Debug, Clone)]
pub enum SettingsCategory {
    Defender,
    Exchange,
    SharePoint,
    Teams,
    All,
}

/// Progress update from worker to TUI
#[derive(Debug, Clone)]
pub struct TaskProgress {
    pub task_id: String,
    pub percent: u16,
    pub message: String,
    pub phase: String,
}

/// Result of a completed task
#[derive(Debug, Clone)]
pub enum TaskResult {
    /// Policies loaded successfully
    PoliciesLoaded { policies: Vec<PolicyData> },
    /// Baseline deployed
    BaselineDeployed { count: usize, message: String },
    /// CA policies deployed
    CaDeployed { count: usize, message: String },
    /// Settings applied
    SettingsApplied { message: String },
    /// Auth test result
    AuthResult { success: bool, message: String },
    /// Connection test with permission checks
    ConnectionTestResult { results: Vec<PermissionCheckResult> },
    // =========================================================================
    // Security Monitoring Results
    // =========================================================================
    /// Sign-in logs loaded
    SignInLogsLoaded { logs: Vec<SignInLogData> },
    /// Risky users loaded
    RiskyUsersLoaded { users: Vec<RiskyUserData> },
    /// Risky sign-ins loaded
    RiskySignInsLoaded { sign_ins: Vec<RiskySignInData> },
    /// Directory audit logs loaded
    DirectoryAuditLoaded { audits: Vec<DirectoryAuditData> },
    /// Security summary loaded
    SecuritySummaryLoaded { summary: SecuritySummaryData },
    /// Tenant security report generated
    TenantReportGenerated { report: Box<TenantSecurityReport> },
    /// Autopilot devices loaded
    AutopilotDevicesLoaded { devices: Vec<AutopilotDeviceData> },
    /// Autopilot profiles loaded
    AutopilotProfilesLoaded { profiles: Vec<AutopilotProfileData> },
    /// Autopilot sync completed
    AutopilotSynced { message: String },
    /// Named locations loaded
    NamedLocationsLoaded { locations: Vec<NamedLocationInfo> },
    /// Task failed
    Error { message: String },
}

// ============================================================================
// Security Monitoring Data Types
// ============================================================================

/// Sign-in log entry for TUI display
#[derive(Debug, Clone)]
pub struct SignInLogData {
    pub user: String,
    pub app: String,
    pub status: String,
    pub location: String,
    pub ip_address: String,
    pub device: String,
    pub timestamp: String,
    pub risk_level: String,
}

/// Risky user entry for TUI display
#[derive(Debug, Clone)]
pub struct RiskyUserData {
    pub display_name: String,
    pub user_principal_name: String,
    pub risk_level: String,
    pub risk_state: String,
    pub risk_detail: String,
    pub last_updated: String,
}

/// Risky sign-in entry for TUI display
#[derive(Debug, Clone)]
pub struct RiskySignInData {
    pub user: String,
    pub app: String,
    pub risk_level: String,
    pub risk_state: String,
    pub risk_detail: String,
    pub location: String,
    pub ip_address: String,
    pub timestamp: String,
}

/// Directory audit entry for TUI display
#[derive(Debug, Clone)]
pub struct DirectoryAuditData {
    pub activity: String,
    pub category: String,
    pub initiated_by: String,
    pub target: String,
    pub result: String,
    pub timestamp: String,
}

/// Security summary for dashboard
#[derive(Debug, Clone)]
pub struct SecuritySummaryData {
    pub total_risky_users: usize,
    pub high_risk_users: usize,
    pub medium_risk_users: usize,
    pub low_risk_users: usize,
    pub recent_risky_sign_ins: usize,
    pub failed_sign_ins_24h: usize,
    pub recent_admin_actions: usize,
}

// ============================================================================
// Autopilot Data Types
// ============================================================================

/// Autopilot device data for TUI display
#[derive(Debug, Clone)]
pub struct AutopilotDeviceData {
    pub serial_number: String,
    pub model: String,
    pub manufacturer: String,
    pub group_tag: String,
    pub enrollment_state: String,
    pub last_contacted: String,
}

/// Autopilot deployment profile data for TUI display
#[derive(Debug, Clone)]
pub struct AutopilotProfileData {
    pub name: String,
    pub description: String,
    pub device_type: String,
    pub deployment_mode: String,
    pub assigned_devices: usize,
}

// ============================================================================
// Comprehensive Tenant Security Report
// ============================================================================

/// Comprehensive tenant security report for HTML export
/// Gathers all relevant data in one async operation for MSP client reporting
#[derive(Debug, Clone)]
pub struct TenantSecurityReport {
    /// Tenant information
    pub tenant_name: String,
    pub tenant_id: String,
    pub report_generated_at: String,

    /// Overall security grade (A-F)
    pub security_grade: String,
    /// Numeric compliance score (0-100)
    pub compliance_score: u8,

    /// Security Defaults status
    pub security_defaults_enabled: bool,

    /// MFA Status
    pub mfa_status: MfaStatus,

    /// Conditional Access summary
    pub ca_summary: CaPolicySummary,

    /// Named Locations (for country blocking)
    pub named_locations: Vec<NamedLocationInfo>,

    /// Intune summary
    pub intune_summary: IntuneSummary,

    /// Security findings and recommendations
    pub findings: Vec<SecurityFinding>,

    /// SCuBA alignment score (if available)
    pub scuba_alignment: Option<ScubaAlignment>,

    /// Recent changes from audit trail
    pub recent_changes: Vec<AuditChange>,
}

/// MFA status information
#[derive(Debug, Clone)]
pub struct MfaStatus {
    /// Whether MFA is enforced via CA policies
    pub enforced_by_ca: bool,
    /// Number of users registered for MFA (if available)
    pub registered_users: Option<usize>,
    /// Number of users total
    pub total_users: Option<usize>,
    /// MFA methods allowed
    pub methods_allowed: Vec<String>,
}

/// Conditional Access policy summary
#[derive(Debug, Clone)]
pub struct CaPolicySummary {
    /// Total CA policies
    pub total_policies: usize,
    /// Policies in enabled state
    pub enabled_count: usize,
    /// Policies in report-only mode
    pub report_only_count: usize,
    /// Policies disabled
    pub disabled_count: usize,
    /// Key policy checks
    pub has_mfa_policy: bool,
    pub has_legacy_auth_block: bool,
    pub has_location_policy: bool,
    pub has_device_compliance: bool,
    pub has_admin_protection: bool,
    /// List of policy names by category
    pub policies_by_category: Vec<(String, Vec<String>)>,
}

/// Named location information
#[derive(Debug, Clone)]
pub struct NamedLocationInfo {
    pub name: String,
    pub location_type: String, // "country" or "ip"
    pub is_trusted: bool,
    pub countries: Vec<String>,
    pub ip_ranges: Vec<String>,
}

/// Intune summary
#[derive(Debug, Clone)]
pub struct IntuneSummary {
    /// Total compliance policies
    pub compliance_policies: usize,
    /// Total configuration policies
    pub configuration_policies: usize,
    /// Settings catalog policies
    pub settings_catalog_policies: usize,
    /// Managed apps
    pub managed_apps: usize,
    /// Platforms covered
    pub platforms: Vec<String>,
}

/// Security finding for the report
#[derive(Debug, Clone)]
pub struct SecurityFinding {
    pub severity: String, // CRITICAL, HIGH, MEDIUM, LOW, INFO
    pub category: String,
    pub title: String,
    pub description: String,
    pub recommendation: String,
}

/// SCuBA alignment check
#[derive(Debug, Clone)]
pub struct ScubaAlignment {
    /// Overall alignment score
    pub score: u8,
    /// Checks performed
    pub total_checks: usize,
    /// Checks passed
    pub passed_checks: usize,
    /// Categories assessed
    pub categories: Vec<(String, u8, usize, usize)>, // (name, score, passed, total)
}

/// Audit change entry for report
#[derive(Debug, Clone)]
pub struct AuditChange {
    pub timestamp: String,
    pub category: String,
    pub action: String,
    pub target: String,
    pub details: Option<String>,
}

/// Permission check result for connection testing
#[derive(Debug, Clone)]
pub struct PermissionCheckResult {
    /// Name of the permission/capability being tested
    pub name: String,
    /// Whether the check passed
    pub success: bool,
    /// Detailed message (error or success info)
    pub message: String,
    /// Required permission scope
    pub required_permission: String,
    /// API endpoint tested
    pub endpoint: String,
}

/// Policy data returned from Graph
#[derive(Debug, Clone)]
pub struct PolicyData {
    pub name: String,
    pub policy_type: String,
    pub status: String,
    pub platform: String,
    pub assignments: usize,
    pub last_modified: String,
}

/// Messages sent from worker to TUI
#[derive(Debug, Clone)]
pub enum TaskResponse {
    /// Progress update
    Progress(TaskProgress),
    /// Task completed
    Completed {
        task_id: String,
        result: Box<TaskResult>,
    },
    /// Worker is ready
    Ready,
}

/// Error type for task submission failures
#[derive(Debug)]
pub enum TaskSendError {
    /// Channel is full (back-pressure)
    ChannelFull(TaskEnvelope),
    /// Channel is disconnected (worker died)
    Disconnected(TaskEnvelope),
}

impl std::fmt::Display for TaskSendError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::ChannelFull(_) => write!(f, "Task queue is full - please wait"),
            Self::Disconnected(_) => write!(f, "Worker unavailable - restart TUI"),
        }
    }
}

impl std::error::Error for TaskSendError {}

/// Handle for sending tasks to the worker
pub struct TaskSender {
    tx: Sender<TaskEnvelope>,
}

impl TaskSender {
    /// Send a task envelope to the worker (blocking)
    pub fn send(&self, envelope: TaskEnvelope) -> std::result::Result<(), TaskSendError> {
        self.tx
            .send(envelope.clone())
            .map_err(|_| TaskSendError::Disconnected(envelope))
    }

    /// Try to send without blocking - returns error if channel full or disconnected
    pub fn try_send(&self, envelope: TaskEnvelope) -> std::result::Result<(), TaskSendError> {
        match self.tx.try_send(envelope) {
            Ok(()) => Ok(()),
            Err(TrySendError::Full(env)) => Err(TaskSendError::ChannelFull(env)),
            Err(TrySendError::Disconnected(env)) => Err(TaskSendError::Disconnected(env)),
        }
    }

    /// Check if the worker is still connected
    /// Note: This is a best-effort check - channel could disconnect after this returns
    pub fn is_connected(&self) -> bool {
        // The only reliable way to know is to try sending
        // This returns true if channel exists (even if empty)
        self.tx.capacity().is_some()
    }

    /// Request graceful shutdown
    pub fn shutdown(&self) {
        let envelope = TaskEnvelope::new(TaskRequest::Shutdown);
        let _ = self.tx.send(envelope);
    }

    /// Create a test stub that can be used in unit tests
    /// The channel is connected but no worker is listening
    #[cfg(test)]
    pub fn test_stub() -> Self {
        let (tx, _rx) = bounded::<TaskEnvelope>(1);
        Self { tx }
    }
}

/// Handle for receiving responses from the worker
pub struct TaskReceiver {
    rx: Receiver<TaskResponse>,
}

impl TaskReceiver {
    /// Try to receive a response without blocking
    pub fn try_recv(&self) -> Option<TaskResponse> {
        self.rx.try_recv().ok()
    }

    /// Drain all available responses
    pub fn drain(&self) -> Vec<TaskResponse> {
        let mut responses = Vec::new();
        while let Some(resp) = self.try_recv() {
            responses.push(resp);
        }
        responses
    }
}

/// Spawn the background task worker
/// Returns handles for sending requests and receiving responses
pub fn spawn_task_worker(config: ConfigManager) -> (TaskSender, TaskReceiver) {
    let (request_tx, request_rx) = bounded::<TaskEnvelope>(32);
    let (response_tx, response_rx) = bounded::<TaskResponse>(64);

    let config = Arc::new(config);

    thread::spawn(move || {
        // Create a new tokio runtime for this thread
        let rt = match tokio::runtime::Builder::new_current_thread()
            .enable_all()
            .build()
        {
            Ok(rt) => rt,
            Err(e) => {
                tracing::error!("Failed to create async runtime: {}", e);
                return;
            }
        };

        rt.block_on(async move {
            // Signal that worker is ready
            let _ = response_tx.send(TaskResponse::Ready);
            tracing::info!("Task worker ready");

            while let Ok(envelope) = request_rx.recv() {
                // Extract the TUI-provided task ID - this is the single source of truth
                let task_id = envelope.id;
                tracing::debug!("Processing task: {}", task_id);

                match envelope.request {
                    TaskRequest::Shutdown => {
                        tracing::info!("Task worker shutting down");
                        break;
                    }
                    TaskRequest::LoadPolicies {
                        tenant_name,
                        policy_type,
                    } => {
                        // Echo back the TUI-provided ID in all responses
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Connecting to Graph API...".into(),
                            phase: "init".into(),
                        }));

                        let result = load_policies_async(
                            &config,
                            &tenant_name,
                            &policy_type,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::DeployBaseline {
                        tenant_name,
                        baseline_type,
                        baseline_data,
                    } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: format!("Preparing {} baseline...", baseline_type),
                            phase: "init".into(),
                        }));

                        let result = deploy_baseline_async(
                            &config,
                            &tenant_name,
                            &baseline_type,
                            &baseline_data,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::DeployConditionalAccess { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Generating CA policies...".into(),
                            phase: "init".into(),
                        }));

                        let result =
                            deploy_ca_async(&config, &tenant_name, &response_tx, &task_id).await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::ApplySettings {
                        tenant_name,
                        category,
                        settings,
                    } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Applying settings...".into(),
                            phase: "init".into(),
                        }));

                        let result = apply_settings_async(
                            &config,
                            &tenant_name,
                            &category,
                            &settings,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::TestAuth { tenant_name } => {
                        let result = test_auth_async(&config, &tenant_name).await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::TestConnection { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Testing connection and permissions...".into(),
                            phase: "init".into(),
                        }));
                        let result =
                            test_connection_async(&config, &tenant_name, &response_tx, &task_id)
                                .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    // =========================================================
                    // Security Monitoring Tasks
                    // =========================================================
                    TaskRequest::FetchSignInLogs { tenant_name, limit } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching sign-in logs...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_signin_logs_async(
                            &config,
                            &tenant_name,
                            limit,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::FetchRiskyUsers { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching risky users...".into(),
                            phase: "init".into(),
                        }));
                        let result =
                            fetch_risky_users_async(&config, &tenant_name, &response_tx, &task_id)
                                .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::FetchRiskySignIns { tenant_name, limit } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching risky sign-ins...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_risky_signins_async(
                            &config,
                            &tenant_name,
                            limit,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::FetchDirectoryAudit { tenant_name, limit } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching directory audit logs...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_directory_audit_async(
                            &config,
                            &tenant_name,
                            limit,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::FetchSecuritySummary { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Fetching security summary...".into(),
                            phase: "init".into(),
                        }));
                        let result = fetch_security_summary_async(
                            &config,
                            &tenant_name,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::GenerateTenantReport { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Generating comprehensive tenant report...".into(),
                            phase: "init".into(),
                        }));
                        let result = generate_tenant_report_async(
                            &config,
                            &tenant_name,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::LoadAutopilotDevices { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Loading Autopilot devices...".into(),
                            phase: "init".into(),
                        }));
                        let result = load_autopilot_devices_async(
                            &config,
                            &tenant_name,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::LoadAutopilotProfiles { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Loading Autopilot profiles...".into(),
                            phase: "init".into(),
                        }));
                        let result = load_autopilot_profiles_async(
                            &config,
                            &tenant_name,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::SyncAutopilot { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Syncing Autopilot devices...".into(),
                            phase: "init".into(),
                        }));
                        let result =
                            sync_autopilot_async(&config, &tenant_name, &response_tx, &task_id)
                                .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                    TaskRequest::LoadNamedLocations { tenant_name } => {
                        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                            task_id: task_id.clone(),
                            percent: 0,
                            message: "Loading Named Locations...".into(),
                            phase: "init".into(),
                        }));
                        let result = load_named_locations_async(
                            &config,
                            &tenant_name,
                            &response_tx,
                            &task_id,
                        )
                        .await;
                        let _ = response_tx.send(TaskResponse::Completed {
                            task_id,
                            result: Box::new(result),
                        });
                    }
                }
            }
        });
    });

    (
        TaskSender { tx: request_tx },
        TaskReceiver { rx: response_rx },
    )
}

// ============================================================================
// Async Task Implementations
// ============================================================================

async fn load_policies_async(
    config: &ConfigManager,
    tenant_name: &str,
    policy_type: &PolicyType,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    // Get Graph client
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 30,
        message: "Fetching policies...".into(),
        phase: "fetch".into(),
    }));

    // Fetch policies based on type
    let policies = match policy_type {
        PolicyType::ConditionalAccess => fetch_ca_policies(&client).await,
        PolicyType::Compliance => fetch_compliance_policies(&client).await,
        PolicyType::Configuration | PolicyType::SettingsCatalog => {
            fetch_config_policies(&client).await
        }
        PolicyType::Apps => fetch_app_policies(&client).await,
        PolicyType::All => fetch_all_policies(&client).await,
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    match policies {
        Ok(p) => TaskResult::PoliciesLoaded { policies: p },
        Err(e) => TaskResult::Error {
            message: e.to_string(),
        },
    }
}

async fn fetch_ca_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct CaResponse {
        value: Vec<CaPolicy>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct CaPolicy {
        #[allow(dead_code)]
        id: String,
        display_name: String,
        state: String,
        #[serde(default)]
        modified_date_time: Option<String>,
    }

    let response: CaResponse = client.get("identity/conditionalAccess/policies").await
        .map_err(|e| {
            // Enhance error message for permission issues
            let err_str = e.to_string();
            if err_str.contains("403") || err_str.contains("Authorization") {
                crate::error::Ctl365Error::GraphApiError(
                    "Access denied. Ensure the app has 'Policy.Read.All' or 'Policy.ReadWrite.ConditionalAccess' permission.".into()
                )
            } else if err_str.contains("404") {
                crate::error::Ctl365Error::GraphApiError(
                    "Conditional Access API not available. Requires Entra ID P1/P2 license.".into()
                )
            } else {
                e
            }
        })?;

    Ok(response
        .value
        .into_iter()
        .map(|p| PolicyData {
            name: p.display_name,
            policy_type: "Conditional Access".into(),
            status: match p.state.as_str() {
                "enabled" => "Deployed",
                "enabledForReportingButNotEnforced" => "Report-Only",
                "disabled" => "Disabled",
                _ => "Unknown",
            }
            .into(),
            platform: "All".into(),
            assignments: 0, // Would need additional API call
            last_modified: p.modified_date_time.unwrap_or_else(|| "-".into()),
        })
        .collect())
}

async fn fetch_compliance_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct ComplianceResponse {
        value: Vec<CompliancePolicy>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct CompliancePolicy {
        #[allow(dead_code)]
        id: String,
        display_name: String,
        #[serde(default)]
        last_modified_date_time: Option<String>,
    }

    let response: ComplianceResponse = client
        .get_beta("deviceManagement/deviceCompliancePolicies")
        .await?;

    Ok(response
        .value
        .into_iter()
        .map(|p| PolicyData {
            name: p.display_name,
            policy_type: "Compliance".into(),
            status: "Deployed".into(),
            platform: "Windows".into(), // Would need to parse from policy
            assignments: 0,
            last_modified: p.last_modified_date_time.unwrap_or_else(|| "-".into()),
        })
        .collect())
}

async fn fetch_config_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct ConfigResponse {
        value: Vec<ConfigPolicy>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct ConfigPolicy {
        #[allow(dead_code)]
        id: String,
        name: String,
        #[serde(default)]
        last_modified_date_time: Option<String>,
    }

    let response: ConfigResponse = client
        .get_beta("deviceManagement/configurationPolicies")
        .await?;

    Ok(response
        .value
        .into_iter()
        .map(|p| PolicyData {
            name: p.name,
            policy_type: "Settings Catalog".into(),
            status: "Deployed".into(),
            platform: "Windows".into(),
            assignments: 0,
            last_modified: p.last_modified_date_time.unwrap_or_else(|| "-".into()),
        })
        .collect())
}

async fn fetch_app_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    #[derive(serde::Deserialize)]
    struct AppResponse {
        value: Vec<App>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct App {
        #[allow(dead_code)]
        id: String,
        display_name: String,
        #[serde(default, rename = "@odata.type")]
        odata_type: Option<String>,
        #[serde(default)]
        last_modified_date_time: Option<String>,
    }

    let response: AppResponse = client
        .get_beta("deviceAppManagement/mobileApps?$top=50")
        .await?;

    Ok(response
        .value
        .into_iter()
        .map(|a| {
            let app_type = a
                .odata_type
                .as_deref()
                .map(|t| t.replace("#microsoft.graph.", "").replace("App", ""))
                .unwrap_or_else(|| "Unknown".into());
            PolicyData {
                name: a.display_name,
                policy_type: app_type,
                status: "Deployed".into(),
                platform: "Windows".into(),
                assignments: 0,
                last_modified: a.last_modified_date_time.unwrap_or_else(|| "-".into()),
            }
        })
        .collect())
}

async fn fetch_all_policies(client: &crate::graph::GraphClient) -> Result<Vec<PolicyData>> {
    let mut all = Vec::new();

    // Fetch each type, ignoring errors for individual types
    if let Ok(ca) = fetch_ca_policies(client).await {
        all.extend(ca);
    }
    if let Ok(compliance) = fetch_compliance_policies(client).await {
        all.extend(compliance);
    }
    if let Ok(config) = fetch_config_policies(client).await {
        all.extend(config);
    }

    Ok(all)
}

async fn deploy_baseline_async(
    config: &ConfigManager,
    tenant_name: &str,
    baseline_type: &str,
    baseline_data: &serde_json::Value,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let policies = baseline_data
        .get("policies")
        .and_then(|p| p.as_array())
        .map(|a| a.to_vec())
        .unwrap_or_default();

    let total = policies.len();
    let mut deployed = 0;
    let mut errors = Vec::new();

    for (i, policy) in policies.iter().enumerate() {
        let percent = ((i + 1) * 100 / total.max(1)) as u16;
        let policy_name = policy
            .get("displayName")
            .or_else(|| policy.get("name"))
            .and_then(|n| n.as_str())
            .unwrap_or("Unknown");

        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
            task_id: task_id.to_string(),
            percent,
            message: format!("Deploying: {}", policy_name),
            phase: "deploy".into(),
        }));

        // Determine endpoint based on policy type
        let odata_type = policy
            .get("@odata.type")
            .and_then(|t| t.as_str())
            .unwrap_or("");

        let endpoint = if odata_type.contains("deviceCompliancePolicy") {
            "deviceManagement/deviceCompliancePolicies"
        } else if odata_type.contains("configurationPolicy") {
            "deviceManagement/configurationPolicies"
        } else {
            continue; // Skip unknown types
        };

        match client
            .post_beta::<_, serde_json::Value>(endpoint, policy)
            .await
        {
            Ok(_) => deployed += 1,
            Err(e) => errors.push(format!("{}: {}", policy_name, e)),
        }
    }

    // Record audit
    crate::tui::change_tracker::record_baseline_deployed(baseline_type, deployed, tenant_name);

    if errors.is_empty() {
        TaskResult::BaselineDeployed {
            count: deployed,
            message: format!("Successfully deployed {} policies", deployed),
        }
    } else {
        TaskResult::BaselineDeployed {
            count: deployed,
            message: format!(
                "Deployed {} policies with {} errors: {}",
                deployed,
                errors.len(),
                errors.join("; ")
            ),
        }
    }
}

async fn deploy_ca_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::templates::ca_baseline_2025;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 5,
        message: "Generating 44 CA policies...".into(),
        phase: "generate".into(),
    }));

    // Generate CA policies
    let baseline = ca_baseline_2025::CABaseline2025::generate();
    let policies: Vec<serde_json::Value> = baseline
        .policies
        .iter()
        .map(ca_baseline_2025::CABaseline2025::to_graph_json)
        .collect();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let total = policies.len();
    let mut deployed = 0;
    let mut errors = Vec::new();

    for (i, policy) in policies.iter().enumerate() {
        let percent = 10 + ((i + 1) * 90 / total.max(1)) as u16;
        let policy_name = policy
            .get("displayName")
            .and_then(|n| n.as_str())
            .unwrap_or("Unknown");

        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
            task_id: task_id.to_string(),
            percent,
            message: format!("Deploying: {}", policy_name),
            phase: "deploy".into(),
        }));

        match client
            .post::<_, serde_json::Value>("identity/conditionalAccess/policies", policy)
            .await
        {
            Ok(_) => {
                deployed += 1;
                // Update progress with success
                let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                    task_id: task_id.to_string(),
                    percent,
                    message: format!("✓ Deployed: {} ({}/{})", policy_name, deployed, total),
                    phase: "deploy".into(),
                }));
            }
            Err(e) => {
                let error_msg = e.to_string();
                // Check if policy already exists (409 Conflict)
                if error_msg.contains("409") || error_msg.contains("already exists") {
                    // Skip existing policies silently
                    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                        task_id: task_id.to_string(),
                        percent,
                        message: format!("⊘ Skipped (exists): {}", policy_name),
                        phase: "deploy".into(),
                    }));
                } else {
                    errors.push(format!("{}: {}", policy_name, e));
                }
            }
        }

        // Delay to avoid rate limiting (500ms recommended by Microsoft)
        tokio::time::sleep(std::time::Duration::from_millis(500)).await;
    }

    // Record audit
    crate::tui::change_tracker::record_baseline_deployed("CA Baseline 2025", deployed, tenant_name);

    if errors.is_empty() {
        TaskResult::CaDeployed {
            count: deployed,
            message: format!(
                "Successfully deployed {} CA policies in Report-Only mode",
                deployed
            ),
        }
    } else {
        TaskResult::CaDeployed {
            count: deployed,
            message: format!(
                "Deployed {} policies with {} errors",
                deployed,
                errors.len()
            ),
        }
    }
}

async fn apply_settings_async(
    config: &ConfigManager,
    tenant_name: &str,
    category: &SettingsCategory,
    settings: &std::collections::HashMap<String, bool>,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 20,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    // Build TenantConfiguration from settings
    use crate::tui::settings::TenantConfiguration;
    let mut tenant_config = TenantConfiguration::recommended();

    for (key, &value) in settings {
        match key.as_str() {
            "safe_links" => tenant_config.safe_links_enabled = value,
            "safe_links_teams" => tenant_config.safe_links_teams = value,
            "safe_links_office" => tenant_config.safe_links_office = value,
            "safe_attachments" => tenant_config.safe_attachments_enabled = value,
            "archive" => tenant_config.archive_mailbox = value,
            "forwarding" => tenant_config.external_forwarding_blocked = value,
            "zap" => tenant_config.zap_enabled = value,
            "external_access" => tenant_config.external_access = value,
            "guest_access" => tenant_config.teams_consumer_access = value,
            "meeting_recording" => tenant_config.meeting_recording = value,
            "anonymous_join" => tenant_config.anonymous_meeting_join = value,
            _ => {}
        }
    }

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Applying settings...".into(),
        phase: "apply".into(),
    }));

    let category_name = match category {
        SettingsCategory::Defender => "Defender",
        SettingsCategory::Exchange => "Exchange",
        SettingsCategory::SharePoint => "SharePoint",
        SettingsCategory::Teams => "Teams",
        SettingsCategory::All => "All",
    };

    // Apply based on category
    let result = match category {
        SettingsCategory::Defender => {
            crate::tui::menu::apply_defender_settings_from_config(
                config,
                tenant_name,
                &tenant_config,
            )
            .await
        }
        SettingsCategory::Exchange => {
            crate::tui::menu::apply_exchange_settings_from_config(
                config,
                tenant_name,
                &tenant_config,
            )
            .await
        }
        SettingsCategory::SharePoint => {
            crate::tui::menu::apply_sharepoint_settings_from_config(
                config,
                tenant_name,
                &tenant_config,
            )
            .await
        }
        SettingsCategory::Teams => {
            crate::tui::menu::apply_teams_settings_from_config(config, tenant_name, &tenant_config)
                .await
        }
        SettingsCategory::All => {
            crate::tui::menu::apply_all_settings_from_config(config, tenant_name, &tenant_config)
                .await
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    match result {
        Ok(msg) => {
            crate::tui::change_tracker::record_setting_change(
                category_name,
                "Settings Applied",
                None,
                "Configured via TUI",
                tenant_name,
            );
            TaskResult::SettingsApplied { message: msg }
        }
        Err(e) => {
            crate::tui::change_tracker::record_error(
                "Settings",
                category_name,
                &e.to_string(),
                tenant_name,
            );
            TaskResult::Error {
                message: e.to_string(),
            }
        }
    }
}

async fn test_auth_async(config: &ConfigManager, tenant_name: &str) -> TaskResult {
    use crate::graph::GraphClient;

    match GraphClient::from_config(config, tenant_name).await {
        Ok(client) => {
            // Try a simple API call to verify token works
            #[derive(serde::Deserialize)]
            struct OrgInfo {
                #[serde(default)]
                value: Vec<serde_json::Value>,
            }

            match client.get::<OrgInfo>("organization").await {
                Ok(_) => {
                    crate::tui::change_tracker::record_auth(tenant_name, true, None);
                    TaskResult::AuthResult {
                        success: true,
                        message: format!("Successfully authenticated to {}", tenant_name),
                    }
                }
                Err(e) => {
                    crate::tui::change_tracker::record_auth(
                        tenant_name,
                        false,
                        Some(&e.to_string()),
                    );
                    TaskResult::AuthResult {
                        success: false,
                        message: format!("API call failed: {}", e),
                    }
                }
            }
        }
        Err(e) => {
            crate::tui::change_tracker::record_auth(tenant_name, false, Some(&e.to_string()));
            TaskResult::AuthResult {
                success: false,
                message: format!("Authentication failed: {}", e),
            }
        }
    }
}

/// Test connection and verify API permissions
///
/// Tests multiple Graph API endpoints to verify the app registration has
/// the required permissions for ctl365 operations.
async fn test_connection_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 5,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::ConnectionTestResult {
                results: vec![PermissionCheckResult {
                    name: "Authentication".into(),
                    success: false,
                    message: format!("Failed to authenticate: {}", e),
                    required_permission: "Valid client credentials".into(),
                    endpoint: "OAuth token endpoint".into(),
                }],
            };
        }
    };

    let mut results = Vec::new();

    // Define permission checks with their endpoints and required scopes
    let checks: Vec<(&str, &str, &str, bool)> = vec![
        // (name, endpoint, required_permission, is_beta)
        (
            "Organization Info",
            "organization",
            "Organization.Read.All",
            false,
        ),
        (
            "Directory (Groups)",
            "groups?$top=1",
            "Group.Read.All",
            false,
        ),
        (
            "Conditional Access Policies",
            "identity/conditionalAccess/policies",
            "Policy.Read.All",
            false,
        ),
        (
            "Device Management",
            "deviceManagement",
            "DeviceManagementConfiguration.Read.All",
            false,
        ),
        (
            "Compliance Policies",
            "deviceManagement/deviceCompliancePolicies?$top=1",
            "DeviceManagementConfiguration.Read.All",
            true,
        ),
        (
            "Configuration Policies",
            "deviceManagement/configurationPolicies?$top=1",
            "DeviceManagementConfiguration.Read.All",
            true,
        ),
        (
            "Mobile Apps",
            "deviceAppManagement/mobileApps?$top=1",
            "DeviceManagementApps.Read.All",
            true,
        ),
        (
            "Sign-in Logs",
            "auditLogs/signIns?$top=1",
            "AuditLog.Read.All",
            false,
        ),
        (
            "Risky Users",
            "identityProtection/riskyUsers?$top=1",
            "IdentityRiskyUser.Read.All",
            false,
        ),
    ];

    let total_checks = checks.len();

    // Add initial auth success
    results.push(PermissionCheckResult {
        name: "Authentication".into(),
        success: true,
        message: format!("Successfully authenticated to {}", tenant_name),
        required_permission: "Valid client credentials".into(),
        endpoint: "OAuth token endpoint".into(),
    });

    for (i, (name, endpoint, permission, is_beta)) in checks.iter().enumerate() {
        let percent = ((i + 1) * 100 / (total_checks + 1)) as u16;
        let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
            task_id: task_id.to_string(),
            percent,
            message: format!("Testing {}...", name),
            phase: "check".into(),
        }));

        #[derive(serde::Deserialize)]
        struct GenericResponse {
            #[serde(default)]
            value: Option<Vec<serde_json::Value>>,
            #[serde(default)]
            id: Option<String>,
        }

        let result: crate::error::Result<GenericResponse> = if *is_beta {
            client.get_beta(endpoint).await
        } else {
            client.get(endpoint).await
        };

        let check_result = match result {
            Ok(_) => PermissionCheckResult {
                name: name.to_string(),
                success: true,
                message: "OK".into(),
                required_permission: permission.to_string(),
                endpoint: endpoint.to_string(),
            },
            Err(e) => {
                let err_str = e.to_string();
                let message = if err_str.contains("403") || err_str.contains("Authorization") {
                    format!("Access denied - missing permission: {}", permission)
                } else if err_str.contains("404") {
                    "Not found (may require license)".into()
                } else if err_str.contains("400") {
                    "Bad request (API may not be enabled)".into()
                } else {
                    format!("Error: {}", err_str)
                };

                PermissionCheckResult {
                    name: name.to_string(),
                    success: false,
                    message,
                    required_permission: permission.to_string(),
                    endpoint: endpoint.to_string(),
                }
            }
        };

        results.push(check_result);
    }

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    TaskResult::ConnectionTestResult { results }
}

// ============================================================================
// Security Monitoring Async Functions
// ============================================================================

async fn fetch_signin_logs_async(
    config: &ConfigManager,
    tenant_name: &str,
    limit: u32,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching sign-in logs...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_recent_sign_ins(&client, limit).await {
        Ok(logs) => {
            let data: Vec<SignInLogData> = logs
                .into_iter()
                .map(|log| SignInLogData {
                    user: log
                        .user_display_name
                        .unwrap_or_else(|| log.user_principal_name.clone().unwrap_or_default()),
                    app: log.app_display_name.unwrap_or_default(),
                    status: log
                        .status
                        .map(|s| {
                            if s.error_code == Some(0) {
                                "Success".to_string()
                            } else {
                                s.failure_reason.unwrap_or_else(|| "Failed".to_string())
                            }
                        })
                        .unwrap_or_else(|| "Unknown".to_string()),
                    location: log
                        .location
                        .map(|l| {
                            format!(
                                "{}, {}",
                                l.city.unwrap_or_default(),
                                l.country_or_region.unwrap_or_default()
                            )
                        })
                        .unwrap_or_default(),
                    ip_address: log.ip_address.unwrap_or_default(),
                    device: log
                        .device_detail
                        .map(|d| d.display_name.or(d.operating_system).unwrap_or_default())
                        .unwrap_or_default(),
                    timestamp: log.created_date_time.to_rfc3339(),
                    risk_level: log
                        .risk_level_during_sign_in
                        .unwrap_or_else(|| "None".to_string()),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} sign-in logs", count),
                phase: "done".into(),
            }));

            TaskResult::SignInLogsLoaded { logs: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'AuditLog.Read.All' permission.".to_string()
            } else {
                format!("Failed to fetch sign-in logs: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_risky_users_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching risky users...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_risky_users(&client, None).await {
        Ok(users) => {
            let data: Vec<RiskyUserData> = users
                .into_iter()
                .map(|user| RiskyUserData {
                    display_name: user.user_display_name.unwrap_or_default(),
                    user_principal_name: user.user_principal_name.unwrap_or_default(),
                    risk_level: user
                        .risk_level
                        .map(|r| r.as_str().to_string())
                        .unwrap_or_else(|| "None".to_string()),
                    risk_state: user
                        .risk_state
                        .map(|r| format!("{:?}", r))
                        .unwrap_or_else(|| "Unknown".to_string()),
                    risk_detail: user.risk_detail.unwrap_or_default(),
                    last_updated: user
                        .risk_last_updated_date_time
                        .map(|dt| dt.to_rfc3339())
                        .unwrap_or_default(),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} risky users", count),
                phase: "done".into(),
            }));

            TaskResult::RiskyUsersLoaded { users: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'IdentityRiskyUser.Read.All' permission (requires Entra ID P1/P2).".to_string()
            } else if err_str.contains("404") {
                "Identity Protection not available. Requires Entra ID P1/P2 license.".to_string()
            } else {
                format!("Failed to fetch risky users: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_risky_signins_async(
    config: &ConfigManager,
    tenant_name: &str,
    limit: u32,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching risky sign-ins...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_risky_sign_ins(&client, Some(limit)).await {
        Ok(sign_ins) => {
            let data: Vec<RiskySignInData> = sign_ins
                .into_iter()
                .map(|si| RiskySignInData {
                    user: si
                        .user_display_name
                        .unwrap_or_else(|| si.user_principal_name.clone().unwrap_or_default()),
                    app: "N/A".to_string(), // RiskySignIn doesn't have app_display_name
                    risk_level: si
                        .risk_level
                        .map(|r| r.as_str().to_string())
                        .unwrap_or_else(|| "None".to_string()),
                    risk_state: si
                        .risk_state
                        .map(|r| format!("{:?}", r))
                        .unwrap_or_else(|| "Unknown".to_string()),
                    risk_detail: si.risk_detail.unwrap_or_default(),
                    location: si
                        .location
                        .map(|l| {
                            format!(
                                "{}, {}",
                                l.city.unwrap_or_default(),
                                l.country_or_region.unwrap_or_default()
                            )
                        })
                        .unwrap_or_default(),
                    ip_address: si.ip_address.unwrap_or_default(),
                    timestamp: si
                        .created_date_time
                        .map(|dt| dt.to_rfc3339())
                        .unwrap_or_default(),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} risky sign-ins", count),
                phase: "done".into(),
            }));

            TaskResult::RiskySignInsLoaded { sign_ins: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'IdentityRiskEvent.Read.All' permission (requires Entra ID P2).".to_string()
            } else if err_str.contains("404") {
                "Risky sign-ins not available. Requires Entra ID P2 license.".to_string()
            } else {
                format!("Failed to fetch risky sign-ins: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_directory_audit_async(
    config: &ConfigManager,
    tenant_name: &str,
    limit: u32,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching directory audit logs...".into(),
        phase: "fetch".into(),
    }));

    match identity_protection::get_recent_directory_audits(&client, limit).await {
        Ok(audits) => {
            let data: Vec<DirectoryAuditData> = audits
                .into_iter()
                .map(|audit| DirectoryAuditData {
                    activity: audit.activity_display_name,
                    category: audit.category,
                    initiated_by: audit
                        .initiated_by
                        .map(|i| {
                            i.user.and_then(|u| u.display_name).unwrap_or_else(|| {
                                i.app.and_then(|a| a.display_name).unwrap_or_default()
                            })
                        })
                        .unwrap_or_default(),
                    target: audit
                        .target_resources
                        .first()
                        .and_then(|t| t.display_name.clone())
                        .unwrap_or_default(),
                    result: audit
                        .result
                        .map(|r| format!("{:?}", r))
                        .unwrap_or_else(|| "Unknown".to_string()),
                    timestamp: audit.activity_date_time.to_rfc3339(),
                })
                .collect();

            let count = data.len();
            let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
                task_id: task_id.to_string(),
                percent: 100,
                message: format!("Loaded {} audit entries", count),
                phase: "done".into(),
            }));

            TaskResult::DirectoryAuditLoaded { audits: data }
        }
        Err(e) => {
            let err_str = e.to_string();
            let message = if err_str.contains("403") || err_str.contains("Authorization") {
                "Access denied. Ensure the app has 'AuditLog.Read.All' permission.".to_string()
            } else {
                format!("Failed to fetch directory audit logs: {}", e)
            };
            TaskResult::Error { message }
        }
    }
}

async fn fetch_security_summary_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::identity_protection;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 30,
        message: "Fetching security data...".into(),
        phase: "fetch".into(),
    }));

    // Fetch various security metrics - allow partial failures
    let risky_users = identity_protection::get_risky_users(&client, None)
        .await
        .unwrap_or_default();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Processing risky users...".into(),
        phase: "process".into(),
    }));

    let high_risk = risky_users
        .iter()
        .filter(|u| {
            matches!(
                u.risk_level,
                Some(crate::graph::identity_protection::RiskLevel::High)
            )
        })
        .count();
    let medium_risk = risky_users
        .iter()
        .filter(|u| {
            matches!(
                u.risk_level,
                Some(crate::graph::identity_protection::RiskLevel::Medium)
            )
        })
        .count();
    let low_risk = risky_users
        .iter()
        .filter(|u| {
            matches!(
                u.risk_level,
                Some(crate::graph::identity_protection::RiskLevel::Low)
            )
        })
        .count();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 70,
        message: "Fetching sign-in data...".into(),
        phase: "fetch".into(),
    }));

    let risky_sign_ins = identity_protection::get_risky_sign_ins(&client, Some(100))
        .await
        .unwrap_or_default();
    let failed_sign_ins = identity_protection::get_failed_sign_ins(&client, 100)
        .await
        .unwrap_or_default();

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 90,
        message: "Fetching audit data...".into(),
        phase: "fetch".into(),
    }));

    let recent_audits = identity_protection::get_recent_directory_audits(&client, 50)
        .await
        .unwrap_or_default();

    let summary = SecuritySummaryData {
        total_risky_users: risky_users.len(),
        high_risk_users: high_risk,
        medium_risk_users: medium_risk,
        low_risk_users: low_risk,
        recent_risky_sign_ins: risky_sign_ins.len(),
        failed_sign_ins_24h: failed_sign_ins.len(),
        recent_admin_actions: recent_audits.len(),
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Security summary loaded".into(),
        phase: "done".into(),
    }));

    TaskResult::SecuritySummaryLoaded { summary }
}

// ============================================================================
// Comprehensive Tenant Report Generation
// ============================================================================

/// Generate a comprehensive tenant security report
/// This fetches all necessary data in one async operation for efficient reporting
async fn generate_tenant_report_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;
    use crate::graph::conditional_access;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 5,
        message: "Authenticating...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Authentication failed: {}", e),
            };
        }
    };

    let mut findings = Vec::new();
    let now = chrono::Local::now();

    // Get tenant ID
    let tenant_id = get_tenant_id(&client)
        .await
        .unwrap_or_else(|_| "Unknown".to_string());

    // =========================================================================
    // Step 1: Security Defaults
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 10,
        message: "Checking Security Defaults...".into(),
        phase: "security_defaults".into(),
    }));

    let security_defaults_enabled = conditional_access::get_security_defaults(&client)
        .await
        .map(|v| v["isEnabled"].as_bool().unwrap_or(false))
        .unwrap_or(false);

    if security_defaults_enabled {
        findings.push(SecurityFinding {
            severity: "MEDIUM".to_string(),
            category: "Identity".to_string(),
            title: "Security Defaults Enabled".to_string(),
            description: "Security Defaults are enabled. This provides basic protection but limits advanced CA policies.".to_string(),
            recommendation: "Consider disabling Security Defaults and implementing custom Conditional Access policies for more granular control.".to_string(),
        });
    }

    // =========================================================================
    // Step 2: Conditional Access Policies
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 20,
        message: "Fetching Conditional Access policies...".into(),
        phase: "ca_policies".into(),
    }));

    let ca_policies = conditional_access::list_policies_typed(&client)
        .await
        .unwrap_or_default();

    let enabled_ca = ca_policies.iter().filter(|p| p.state == "enabled").count();
    let report_only_ca = ca_policies
        .iter()
        .filter(|p| p.state == "enabledForReportingButNotEnforced")
        .count();
    let disabled_ca = ca_policies.iter().filter(|p| p.state == "disabled").count();

    // Check for key policies
    let has_mfa_policy = ca_policies.iter().any(|p| {
        p.grant_controls
            .as_ref()
            .and_then(|gc| gc.built_in_controls.as_ref())
            .map(|c| c.iter().any(|ctrl| ctrl == "mfa"))
            .unwrap_or(false)
    });

    let has_legacy_auth_block = ca_policies.iter().any(|p| {
        let name_lower = p.display_name.to_lowercase();
        (name_lower.contains("legacy") || name_lower.contains("block"))
            && p.grant_controls
                .as_ref()
                .and_then(|gc| gc.built_in_controls.as_ref())
                .map(|c| c.iter().any(|ctrl| ctrl == "block"))
                .unwrap_or(false)
    });

    let has_location_policy = ca_policies.iter().any(|p| {
        p.conditions
            .as_ref()
            .and_then(|c| c.locations.as_ref())
            .is_some()
    });

    let has_device_compliance = ca_policies.iter().any(|p| {
        p.grant_controls
            .as_ref()
            .and_then(|gc| gc.built_in_controls.as_ref())
            .map(|c| c.iter().any(|ctrl| ctrl == "compliantDevice"))
            .unwrap_or(false)
    });

    let has_admin_protection = ca_policies.iter().any(|p| {
        p.conditions
            .as_ref()
            .and_then(|c| c.users.as_ref())
            .and_then(|u| u.include_roles.as_ref())
            .map(|r| !r.is_empty())
            .unwrap_or(false)
    });

    // Generate CA findings
    if ca_policies.is_empty() && !security_defaults_enabled {
        findings.push(SecurityFinding {
            severity: "CRITICAL".to_string(),
            category: "Conditional Access".to_string(),
            title: "No Conditional Access Policies".to_string(),
            description:
                "No Conditional Access policies are configured and Security Defaults are disabled."
                    .to_string(),
            recommendation: "Deploy baseline CA policies with: ctl365 ca deploy --baseline 2025"
                .to_string(),
        });
    } else {
        if !has_mfa_policy && !security_defaults_enabled {
            findings.push(SecurityFinding {
                severity: "HIGH".to_string(),
                category: "Conditional Access".to_string(),
                title: "No MFA Enforcement Policy".to_string(),
                description: "No Conditional Access policy enforces MFA.".to_string(),
                recommendation: "Create a CA policy requiring MFA for all users.".to_string(),
            });
        }
        if !has_legacy_auth_block {
            findings.push(SecurityFinding {
                severity: "HIGH".to_string(),
                category: "Conditional Access".to_string(),
                title: "Legacy Authentication Not Blocked".to_string(),
                description: "Legacy authentication protocols (IMAP, POP3, SMTP) are not blocked."
                    .to_string(),
                recommendation: "Create a CA policy to block legacy authentication.".to_string(),
            });
        }
        if enabled_ca == 0 && report_only_ca > 0 {
            findings.push(SecurityFinding {
                severity: "MEDIUM".to_string(),
                category: "Conditional Access".to_string(),
                title: "All CA Policies in Report-Only Mode".to_string(),
                description: format!(
                    "{} CA policies are in report-only mode and not enforcing.",
                    report_only_ca
                ),
                recommendation: "Review sign-in logs and enable policies after validation."
                    .to_string(),
            });
        }
    }

    // Group policies by category for report
    let mut policies_by_category: std::collections::HashMap<String, Vec<String>> =
        std::collections::HashMap::new();
    for p in &ca_policies {
        let category = if p.display_name.starts_with("CAD") {
            "Device/Platform"
        } else if p.display_name.starts_with("CAL") {
            "Location"
        } else if p.display_name.starts_with("CAP") {
            "Protocol"
        } else if p.display_name.starts_with("CAR") {
            "Risk-Based"
        } else if p.display_name.starts_with("CAS") {
            "Service-Specific"
        } else if p.display_name.starts_with("CAU") {
            "User-Based"
        } else {
            "Other"
        };
        policies_by_category
            .entry(category.to_string())
            .or_default()
            .push(p.display_name.clone());
    }

    let ca_summary = CaPolicySummary {
        total_policies: ca_policies.len(),
        enabled_count: enabled_ca,
        report_only_count: report_only_ca,
        disabled_count: disabled_ca,
        has_mfa_policy,
        has_legacy_auth_block,
        has_location_policy,
        has_device_compliance,
        has_admin_protection,
        policies_by_category: policies_by_category.into_iter().collect(),
    };

    // =========================================================================
    // Step 3: Named Locations
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 35,
        message: "Fetching Named Locations...".into(),
        phase: "named_locations".into(),
    }));

    let named_locations = conditional_access::list_named_locations_typed(&client)
        .await
        .unwrap_or_default();

    let named_location_infos: Vec<NamedLocationInfo> = named_locations
        .into_iter()
        .map(|loc| {
            let location_type = if loc.odata_type.contains("country") {
                "country"
            } else {
                "ip"
            };
            NamedLocationInfo {
                name: loc.display_name,
                location_type: location_type.to_string(),
                is_trusted: loc.is_trusted.unwrap_or(false),
                countries: loc.countries_and_regions.unwrap_or_default(),
                ip_ranges: loc
                    .ip_ranges
                    .map(|ranges| ranges.into_iter().map(|r| r.cidr_address).collect())
                    .unwrap_or_default(),
            }
        })
        .collect();

    if named_location_infos.is_empty() && has_location_policy {
        findings.push(SecurityFinding {
            severity: "MEDIUM".to_string(),
            category: "Conditional Access".to_string(),
            title: "Location Policy Without Named Locations".to_string(),
            description: "CA policies reference locations but no Named Locations are configured."
                .to_string(),
            recommendation: "Create Named Locations for trusted countries/IP ranges.".to_string(),
        });
    }

    // =========================================================================
    // Step 4: Intune Policies
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching Intune configuration...".into(),
        phase: "intune".into(),
    }));

    let compliance_policies = fetch_compliance_count(&client).await;
    let config_policies = fetch_config_count(&client).await;
    let settings_catalog = fetch_settings_catalog_count(&client).await;
    let managed_apps = fetch_managed_apps_count(&client).await;

    // Determine platforms
    let mut platforms = Vec::new();
    if compliance_policies > 0 || config_policies > 0 {
        platforms.push("Windows".to_string());
    }
    // Could be expanded to detect actual platforms from policy metadata

    let intune_summary = IntuneSummary {
        compliance_policies,
        configuration_policies: config_policies,
        settings_catalog_policies: settings_catalog,
        managed_apps,
        platforms,
    };

    if compliance_policies == 0 && config_policies == 0 {
        findings.push(SecurityFinding {
            severity: "MEDIUM".to_string(),
            category: "Intune".to_string(),
            title: "No Intune Policies Configured".to_string(),
            description: "No compliance or configuration policies found in Intune.".to_string(),
            recommendation: "Deploy device management baselines with: ctl365 baseline apply"
                .to_string(),
        });
    }

    // =========================================================================
    // Step 5: MFA Status
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 65,
        message: "Checking MFA status...".into(),
        phase: "mfa".into(),
    }));

    let mfa_status = MfaStatus {
        enforced_by_ca: has_mfa_policy || security_defaults_enabled,
        registered_users: None, // Would require additional API call
        total_users: None,
        methods_allowed: vec!["Microsoft Authenticator".to_string(), "Phone".to_string()], // Default
    };

    // =========================================================================
    // Step 6: Recent Audit Changes
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 80,
        message: "Loading audit trail...".into(),
        phase: "audit".into(),
    }));

    let audit_entries = crate::tui::change_tracker::load_all_entries().unwrap_or_default();

    let recent_changes: Vec<AuditChange> = audit_entries
        .into_iter()
        .filter(|e| e.tenant == tenant_name || e.tenant == "all")
        .take(50)
        .map(|e| AuditChange {
            timestamp: e.timestamp,
            category: e.category,
            action: format!("{:?}", e.action),
            target: e.target,
            details: e.details,
        })
        .collect();

    // =========================================================================
    // Step 7: Calculate Security Grade
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 90,
        message: "Calculating security grade...".into(),
        phase: "scoring".into(),
    }));

    let critical_count = findings.iter().filter(|f| f.severity == "CRITICAL").count();
    let high_count = findings.iter().filter(|f| f.severity == "HIGH").count();
    let medium_count = findings.iter().filter(|f| f.severity == "MEDIUM").count();

    // Calculate compliance score based on findings and controls
    let mut score_deductions = 0;
    score_deductions += critical_count * 25;
    score_deductions += high_count * 15;
    score_deductions += medium_count * 5;

    // Add points for good controls
    let mut bonus_points = 0;
    if has_mfa_policy || security_defaults_enabled {
        bonus_points += 15;
    }
    if has_legacy_auth_block {
        bonus_points += 10;
    }
    if has_device_compliance {
        bonus_points += 10;
    }
    if has_location_policy {
        bonus_points += 5;
    }
    if compliance_policies > 0 {
        bonus_points += 10;
    }
    if enabled_ca > 0 {
        bonus_points += 10;
    }

    let compliance_score = (100 - score_deductions as i32 + bonus_points).clamp(0, 100) as u8;

    let security_grade = match compliance_score {
        90..=100 => "A",
        80..=89 => "B",
        70..=79 => "C",
        60..=69 => "D",
        _ => "F",
    }
    .to_string();

    // =========================================================================
    // Step 8: Calculate SCuBA Alignment
    // =========================================================================
    let scuba_alignment = calculate_scuba_alignment(
        security_defaults_enabled,
        &ca_summary,
        &intune_summary,
        &named_location_infos,
        &mfa_status,
    );

    // =========================================================================
    // Build Final Report
    // =========================================================================
    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Report generated successfully".into(),
        phase: "done".into(),
    }));

    let report = TenantSecurityReport {
        tenant_name: tenant_name.to_string(),
        tenant_id,
        report_generated_at: now.format("%Y-%m-%d %H:%M:%S").to_string(),
        security_grade,
        compliance_score,
        security_defaults_enabled,
        mfa_status,
        ca_summary,
        named_locations: named_location_infos,
        intune_summary,
        findings,
        scuba_alignment: Some(scuba_alignment),
        recent_changes,
    };

    TaskResult::TenantReportGenerated {
        report: Box::new(report),
    }
}

// Helper functions for tenant report

async fn get_tenant_id(client: &crate::graph::GraphClient) -> Result<String> {
    #[derive(serde::Deserialize)]
    struct OrgResponse {
        value: Vec<OrgInfo>,
    }
    #[derive(serde::Deserialize)]
    struct OrgInfo {
        id: String,
    }

    let response: OrgResponse = client.get("organization").await?;
    Ok(response
        .value
        .first()
        .map(|o| o.id.clone())
        .unwrap_or_default())
}

async fn fetch_compliance_count(client: &crate::graph::GraphClient) -> usize {
    #[derive(serde::Deserialize)]
    struct CountResponse {
        #[serde(default)]
        value: Vec<serde_json::Value>,
    }

    client
        .get_beta::<CountResponse>("deviceManagement/deviceCompliancePolicies?$top=200")
        .await
        .map(|r| r.value.len())
        .unwrap_or(0)
}

async fn fetch_config_count(client: &crate::graph::GraphClient) -> usize {
    #[derive(serde::Deserialize)]
    struct CountResponse {
        #[serde(default)]
        value: Vec<serde_json::Value>,
    }

    client
        .get_beta::<CountResponse>("deviceManagement/deviceConfigurations?$top=200")
        .await
        .map(|r| r.value.len())
        .unwrap_or(0)
}

async fn fetch_settings_catalog_count(client: &crate::graph::GraphClient) -> usize {
    #[derive(serde::Deserialize)]
    struct CountResponse {
        #[serde(default)]
        value: Vec<serde_json::Value>,
    }

    client
        .get_beta::<CountResponse>("deviceManagement/configurationPolicies?$top=200")
        .await
        .map(|r| r.value.len())
        .unwrap_or(0)
}

async fn fetch_managed_apps_count(client: &crate::graph::GraphClient) -> usize {
    #[derive(serde::Deserialize)]
    struct CountResponse {
        #[serde(default)]
        value: Vec<serde_json::Value>,
    }

    client
        .get_beta::<CountResponse>("deviceAppManagement/mobileApps?$top=200")
        .await
        .map(|r| r.value.len())
        .unwrap_or(0)
}

/// Calculate SCuBA (Secure Cloud Business Applications) alignment score
/// Based on CISA SCuBA guidelines for Microsoft 365
fn calculate_scuba_alignment(
    security_defaults_enabled: bool,
    ca_summary: &CaPolicySummary,
    intune_summary: &IntuneSummary,
    named_locations: &[NamedLocationInfo],
    mfa_status: &MfaStatus,
) -> ScubaAlignment {
    let mut categories: Vec<(String, u8, usize, usize)> = Vec::new();
    let mut total_passed = 0;
    let mut total_checks = 0;

    // =========================================================================
    // Category 1: Entra ID / Identity (MS.AAD)
    // =========================================================================
    let mut aad_passed = 0;
    let aad_total = 8;

    // MS.AAD.1.1 - Legacy authentication SHALL be blocked
    if ca_summary.has_legacy_auth_block {
        aad_passed += 1;
    }

    // MS.AAD.2.1 - MFA SHALL be required for all users
    if ca_summary.has_mfa_policy || security_defaults_enabled {
        aad_passed += 1;
    }

    // MS.AAD.2.3 - Phishing-resistant MFA SHOULD be used (check for FIDO2, cert-based)
    // We'll give partial credit if MFA is enabled at all
    if mfa_status.enforced_by_ca {
        aad_passed += 1;
    }

    // MS.AAD.3.1 - Only admins should have access to Azure AD admin portal
    // Can't verify this without more specific data, assume configured if CA policies exist
    if ca_summary.has_admin_protection {
        aad_passed += 1;
    }

    // MS.AAD.4.1 - Guest access shall be restricted
    // Partial credit if location policies exist (indicates access control awareness)
    if ca_summary.has_location_policy {
        aad_passed += 1;
    }

    // MS.AAD.5.1 - Conditional Access policies enabled
    if ca_summary.enabled_count > 0 {
        aad_passed += 1;
    }

    // MS.AAD.6.1 - Device compliance should be required
    if ca_summary.has_device_compliance {
        aad_passed += 1;
    }

    // MS.AAD.7.1 - Sign-in risk policies
    // Give credit if security defaults or multiple CA policies
    if security_defaults_enabled || ca_summary.total_policies >= 3 {
        aad_passed += 1;
    }

    let aad_score = ((aad_passed as f32 / aad_total as f32) * 100.0) as u8;
    categories.push((
        "Entra ID (MS.AAD)".to_string(),
        aad_score,
        aad_passed,
        aad_total,
    ));
    total_passed += aad_passed;
    total_checks += aad_total;

    // =========================================================================
    // Category 2: Exchange Online Protection (MS.EXO)
    // =========================================================================
    let mut exo_passed = 0;
    let exo_total = 6;

    // MS.EXO.1.1 - External sender warnings should be enabled
    // MS.EXO.2.1 - SPF, DKIM, DMARC should be configured
    // MS.EXO.3.1 - Automatic email forwarding should be disabled
    // MS.EXO.4.1 - Malware filter should be enabled
    // MS.EXO.5.1 - Anti-spam policies should be configured
    // MS.EXO.6.1 - Audit logging should be enabled

    // We can't directly query Exchange settings without Exchange permissions,
    // but if Intune/CA are configured, organization likely has EXO configured
    if intune_summary.compliance_policies > 0 || ca_summary.total_policies > 0 {
        exo_passed += 3; // Give credit for 3 basic settings
    }
    if ca_summary.enabled_count > 2 {
        exo_passed += 2; // Give credit for 2 more if multiple policies
    }
    if security_defaults_enabled {
        exo_passed += 1; // Audit logging enabled with security defaults
    }

    let exo_score = ((exo_passed as f32 / exo_total as f32) * 100.0) as u8;
    categories.push((
        "Exchange Online (MS.EXO)".to_string(),
        exo_score,
        exo_passed,
        exo_total,
    ));
    total_passed += exo_passed;
    total_checks += exo_total;

    // =========================================================================
    // Category 3: Defender for Office 365 (MS.DEFENDER)
    // =========================================================================
    let mut defender_passed = 0;
    let defender_total = 5;

    // MS.DEFENDER.1.1 - Safe Links should be enabled
    // MS.DEFENDER.2.1 - Safe Attachments should be enabled
    // MS.DEFENDER.3.1 - Anti-phishing policies should be configured
    // MS.DEFENDER.4.1 - Alerts should be configured
    // MS.DEFENDER.5.1 - Automated investigation should be enabled

    // Estimate based on other security controls
    if ca_summary.total_policies >= 5 {
        defender_passed += 3; // Mature tenant likely has Defender
    } else if ca_summary.total_policies >= 2 {
        defender_passed += 2;
    }
    if intune_summary.compliance_policies > 0 {
        defender_passed += 1;
    }
    if ca_summary.has_mfa_policy {
        defender_passed += 1; // Security-conscious org
    }

    let defender_score = ((defender_passed as f32 / defender_total as f32) * 100.0) as u8;
    categories.push((
        "Defender for O365 (MS.DEFENDER)".to_string(),
        defender_score,
        defender_passed,
        defender_total,
    ));
    total_passed += defender_passed;
    total_checks += defender_total;

    // =========================================================================
    // Category 4: SharePoint & OneDrive (MS.SHAREPOINT)
    // =========================================================================
    let mut sp_passed = 0;
    let sp_total = 5;

    // MS.SHAREPOINT.1.1 - External sharing should be restricted
    // MS.SHAREPOINT.2.1 - Default link type should be organization-specific
    // MS.SHAREPOINT.3.1 - Expiration for guest access should be configured
    // MS.SHAREPOINT.4.1 - File access requests should be configured
    // MS.SHAREPOINT.5.1 - Sync should be restricted to managed devices

    // Estimate based on device compliance policies
    if ca_summary.has_device_compliance {
        sp_passed += 3; // Device compliance indicates managed sharing
    }
    if ca_summary.has_location_policy {
        sp_passed += 1; // Network restrictions often accompany SP restrictions
    }
    if intune_summary.configuration_policies > 0 {
        sp_passed += 1; // Config policies suggest sync restrictions
    }

    let sp_score = ((sp_passed as f32 / sp_total as f32) * 100.0) as u8;
    categories.push((
        "SharePoint/OneDrive (MS.SHAREPOINT)".to_string(),
        sp_score,
        sp_passed,
        sp_total,
    ));
    total_passed += sp_passed;
    total_checks += sp_total;

    // =========================================================================
    // Category 5: Microsoft Teams (MS.TEAMS)
    // =========================================================================
    let mut teams_passed = 0;
    let teams_total = 5;

    // MS.TEAMS.1.1 - External access should be restricted
    // MS.TEAMS.2.1 - Guest access should be restricted
    // MS.TEAMS.3.1 - Meeting settings should be configured
    // MS.TEAMS.4.1 - Cloud recording should be controlled
    // MS.TEAMS.5.1 - DLP policies should be enabled

    // Estimate based on overall security posture
    if ca_summary.total_policies >= 3 {
        teams_passed += 2;
    }
    if ca_summary.has_device_compliance {
        teams_passed += 1;
    }
    if !named_locations.is_empty() {
        teams_passed += 1;
    }
    if intune_summary.compliance_policies > 0 {
        teams_passed += 1;
    }

    let teams_score = ((teams_passed as f32 / teams_total as f32) * 100.0) as u8;
    categories.push((
        "Microsoft Teams (MS.TEAMS)".to_string(),
        teams_score,
        teams_passed,
        teams_total,
    ));
    total_passed += teams_passed;
    total_checks += teams_total;

    // =========================================================================
    // Category 6: Power Platform (MS.POWERPLATFORM) - Limited assessment
    // =========================================================================
    let mut pp_passed = 0;
    let pp_total = 3;

    // MS.POWERPLATFORM.1.1 - DLP policies should be configured
    // MS.POWERPLATFORM.2.1 - Environment creation should be restricted
    // MS.POWERPLATFORM.3.1 - Tenant isolation should be configured

    // Basic estimate - security-conscious tenants usually configure Power Platform
    if ca_summary.total_policies >= 5 && intune_summary.compliance_policies > 0 {
        pp_passed += 2;
    } else if ca_summary.total_policies >= 2 {
        pp_passed += 1;
    }

    let pp_score = ((pp_passed as f32 / pp_total as f32) * 100.0) as u8;
    categories.push((
        "Power Platform (MS.POWERPLATFORM)".to_string(),
        pp_score,
        pp_passed,
        pp_total,
    ));
    total_passed += pp_passed;
    total_checks += pp_total;

    // Calculate overall score
    let overall_score = ((total_passed as f32 / total_checks as f32) * 100.0) as u8;

    ScubaAlignment {
        score: overall_score,
        total_checks,
        passed_checks: total_passed,
        categories,
    }
}

// ============================================================================
// Autopilot Functions
// ============================================================================

async fn load_autopilot_devices_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 20,
        message: "Connecting to Graph API...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Failed to authenticate: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching Autopilot devices...".into(),
        phase: "fetch".into(),
    }));

    #[derive(serde::Deserialize)]
    struct AutopilotResponse {
        value: Vec<AutopilotDevice>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct AutopilotDevice {
        serial_number: Option<String>,
        model: Option<String>,
        manufacturer: Option<String>,
        group_tag: Option<String>,
        enrollment_state: Option<String>,
        last_contacted_date_time: Option<String>,
    }

    let response: crate::error::Result<AutopilotResponse> = client
        .get_beta("deviceManagement/windowsAutopilotDeviceIdentities")
        .await;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    match response {
        Ok(resp) => {
            let devices: Vec<AutopilotDeviceData> = resp
                .value
                .into_iter()
                .map(|d| AutopilotDeviceData {
                    serial_number: d.serial_number.unwrap_or_else(|| "Unknown".into()),
                    model: d.model.unwrap_or_else(|| "Unknown".into()),
                    manufacturer: d.manufacturer.unwrap_or_else(|| "Unknown".into()),
                    group_tag: d.group_tag.unwrap_or_else(|| "-".into()),
                    enrollment_state: d.enrollment_state.unwrap_or_else(|| "Unknown".into()),
                    last_contacted: d.last_contacted_date_time.unwrap_or_else(|| "-".into()),
                })
                .collect();
            TaskResult::AutopilotDevicesLoaded { devices }
        }
        Err(e) => TaskResult::Error {
            message: format!("Failed to fetch Autopilot devices: {}", e),
        },
    }
}

async fn load_autopilot_profiles_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 20,
        message: "Connecting to Graph API...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Failed to authenticate: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching Autopilot profiles...".into(),
        phase: "fetch".into(),
    }));

    #[derive(serde::Deserialize)]
    struct ProfileResponse {
        value: Vec<AutopilotProfile>,
    }

    #[derive(serde::Deserialize)]
    #[serde(rename_all = "camelCase")]
    struct AutopilotProfile {
        display_name: Option<String>,
        description: Option<String>,
        device_type: Option<String>,
        #[serde(default, rename = "@odata.type")]
        odata_type: Option<String>,
    }

    let response: crate::error::Result<ProfileResponse> = client
        .get_beta("deviceManagement/windowsAutopilotDeploymentProfiles")
        .await;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    match response {
        Ok(resp) => {
            let profiles: Vec<AutopilotProfileData> = resp
                .value
                .into_iter()
                .map(|p| {
                    let deployment_mode = p
                        .odata_type
                        .as_deref()
                        .map(|t| {
                            if t.contains("azureADJoin") {
                                "User-Driven (Azure AD)"
                            } else if t.contains("activeDirectory") {
                                "User-Driven (Hybrid)"
                            } else {
                                "Standard"
                            }
                        })
                        .unwrap_or("Standard")
                        .to_string();

                    AutopilotProfileData {
                        name: p.display_name.unwrap_or_else(|| "Unnamed".into()),
                        description: p.description.unwrap_or_else(|| "-".into()),
                        device_type: p.device_type.unwrap_or_else(|| "windowsPc".into()),
                        deployment_mode,
                        assigned_devices: 0, // Would need additional API call
                    }
                })
                .collect();
            TaskResult::AutopilotProfilesLoaded { profiles }
        }
        Err(e) => TaskResult::Error {
            message: format!("Failed to fetch Autopilot profiles: {}", e),
        },
    }
}

async fn sync_autopilot_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 20,
        message: "Connecting to Graph API...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Failed to authenticate: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Triggering Autopilot sync...".into(),
        phase: "sync".into(),
    }));

    // Trigger sync via POST to the sync action
    let empty_body = serde_json::json!({});
    let result: crate::error::Result<serde_json::Value> = client
        .post_beta(
            "deviceManagement/windowsAutopilotSettings/sync",
            &empty_body,
        )
        .await;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    match result {
        Ok(_) => TaskResult::AutopilotSynced {
            message:
                "Autopilot sync initiated successfully. Changes may take a few minutes to appear."
                    .into(),
        },
        Err(e) => {
            // 204 No Content is actually a success for this endpoint
            let err_str = e.to_string();
            if err_str.contains("204") || err_str.contains("no content") {
                TaskResult::AutopilotSynced {
                    message: "Autopilot sync initiated successfully.".into(),
                }
            } else {
                TaskResult::Error {
                    message: format!("Failed to trigger sync: {}", e),
                }
            }
        }
    }
}

async fn load_named_locations_async(
    config: &ConfigManager,
    tenant_name: &str,
    response_tx: &Sender<TaskResponse>,
    task_id: &str,
) -> TaskResult {
    use crate::graph::GraphClient;

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 20,
        message: "Connecting to Graph API...".into(),
        phase: "auth".into(),
    }));

    let client = match GraphClient::from_config(config, tenant_name).await {
        Ok(c) => c,
        Err(e) => {
            return TaskResult::Error {
                message: format!("Failed to authenticate: {}", e),
            };
        }
    };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 50,
        message: "Fetching Named Locations...".into(),
        phase: "fetch".into(),
    }));

    let locations =
        match crate::graph::conditional_access::list_named_locations_typed(&client).await {
            Ok(locs) => locs,
            Err(e) => {
                return TaskResult::Error {
                    message: format!("Failed to fetch named locations: {}", e),
                };
            }
        };

    let _ = response_tx.send(TaskResponse::Progress(TaskProgress {
        task_id: task_id.to_string(),
        percent: 100,
        message: "Complete".into(),
        phase: "done".into(),
    }));

    let location_infos: Vec<NamedLocationInfo> = locations
        .into_iter()
        .map(|loc| {
            let location_type = if loc.odata_type.contains("ipNamedLocation") {
                "ip".to_string()
            } else if loc.odata_type.contains("countryNamedLocation") {
                "country".to_string()
            } else {
                "other".to_string()
            };

            let ip_ranges = loc
                .ip_ranges
                .unwrap_or_default()
                .into_iter()
                .map(|r| r.cidr_address)
                .collect();

            NamedLocationInfo {
                name: loc.display_name,
                location_type,
                is_trusted: loc.is_trusted.unwrap_or(false),
                countries: loc.countries_and_regions.unwrap_or_default(),
                ip_ranges,
            }
        })
        .collect();

    TaskResult::NamedLocationsLoaded {
        locations: location_infos,
    }
}
